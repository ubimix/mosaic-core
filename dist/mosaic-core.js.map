{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9067f2c88269d137ad22","webpack:///./src/index.js","webpack:///external \"mosaic-commons\"","webpack:///./src/App.js","webpack:///./src/App.Actions.js","webpack:///./src/App.Api.js","webpack:///./src/App.Component.js","webpack:///./src/App.Store.js","webpack:///./src/React.FilterBox.js","webpack:///./src/React.SearchBoxMixin.js","webpack:///./src/LeafletReactMap.js","webpack:///./src/LeafletFeatureBuilder.js","webpack:///./src/Leaflet.UtfGrid.js","webpack:///./src/LeafletMapViewport.js","webpack:///./src/DataSet.js","webpack:///./src/ActivationTree.js","webpack:///./src/InfiniteScroll.js","webpack:///./src/AbstractSet.js","webpack:///./src/AdapterManager.js","webpack:///./src/CompositeDataSet.js","webpack:///./src/DataSetView.js","webpack:///./src/Dependencies.js","webpack:///./src/Intents.js","webpack:///./src/LeafletDataSetView.js","webpack:///./src/LeafletDataSubsetView.js","webpack:///./src/ReactDataSetMixin.js","webpack:///./src/ViewManager.js","webpack:///./src/URI.js","webpack:///external \"underscore\"","webpack:///external \"mosaic-teleport\"","webpack:///external \"react\"","webpack:///external \"leaflet\"","webpack:///./src/Leaflet.InteractionLayer.js","webpack:///./src/Leaflet.MapTiles.js"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;AC3CA,gD;;;;;;ACAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;;;;;;ACvED;AACA;;AAEA;AACA,wCAAuC;;;;;;;ACJvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACzNA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;;;;;;ACbD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;;;;;;AC3DD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,iCAAgC;AAChC,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,UAAS,qDAAqD;AAC9D;AACA;AACA,UAAS,4BAA4B;AACrC;AACA;AACA;AACA;AACA;AACA,UAAS,2BAA2B;AACpC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;;;;AAIjB;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACpSD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,sBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,UAAS;AACT,MAAK;AACL;;AAEA;;;;;;;ACxJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,kCAAiC;AACjC;AACA;AACA,UAAS;AACT;AACA,8BAA6B;AAC7B;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,wBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AC3ED;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;;AAEA;;;;;;;ACpHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAsE;AACtE;AACA,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC7GA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACrLA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iDAAgD;AAChD;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACtGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA,UAAS;AACT,MAAK;AACL,EAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA,cAAa;AACb;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,EAAC;;AAED;;;;;;;ACxdA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;;;;;;AC5ND;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,+BAA8B;AAC9B;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;;;;;;;ACjLA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AChMA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL,EAAC;;AAED;;;;;;;AC5JA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACvFA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3OA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,2CAA0C,IAAI;AAC9C;AACA,uCAAsC,IAAI;AAC1C;AACA;AACA,iDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpUA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA,EAAC;;AAED;;;;;;;ACrFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACpCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;;;;;;;AC3CA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;AC/CA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtVA,iD;;;;;;ACAA,iD;;;;;;ACAA,iD;;;;;;ACAA,iD;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA,uCAAsC;AACtC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACvHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,4BAA2B,YAAY;AACvC,gCAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mosaic-commons\"), require(\"underscore\"), require(\"mosaic-teleport\"), require(\"react\"), require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"mosaic-commons\", \"underscore\", \"mosaic-teleport\", \"react\", \"leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mosaic-core\"] = factory(require(\"mosaic-commons\"), require(\"underscore\"), require(\"mosaic-teleport\"), require(\"react\"), require(\"leaflet\"));\n\telse\n\t\troot[\"mosaic-core\"] = factory(root[\"mosaic-commons\"], root[\"underscore\"], root[\"mosaic-teleport\"], root[\"react\"], root[\"leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_30__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9067f2c88269d137ad22\n **/","var Mosaic = require('mosaic-commons');\nMosaic.App = require('./App');\nMosaic.App.Actions = require('./App.Actions');\nMosaic.App.Api = require('./App.Api');\nMosaic.App.Component = require('./App.Component');\nMosaic.App.Store = require('./App.Store');\n\nMosaic.React = {\n    FilterBox : require('./React.FilterBox'),\n    SearchBoxMixin : require('./React.SearchBoxMixin')\n};\n\nMosaic.Leaflet = {\n    ReactMap : require('./LeafletReactMap'),\n    FeatureBuilder : require('./LeafletFeatureBuilder'),\n    UtfGrid : require('./Leaflet.UtfGrid'),\n    MapViewport : require('./LeafletMapViewport')\n};\n\nMosaic.Core = {\n    DataSet : require('./DataSet'),\n    ActivationTree : require('./ActivationTree'),\n\n    InfiniteScroll : require('./InfiniteScroll'),\n    AbstractSet : require('./AbstractSet'),\n    AdapterManager : require('./AdapterManager'),\n    CompositeDataSet : require('./CompositeDataSet'),\n    DataSetView : require('./DataSetView'),\n    Dependencies : require('./Dependencies'),\n    Intents : require('./Intents'),\n    LeafletDataSetView : require('./LeafletDataSetView'),\n    LeafletDataSubsetView : require('./LeafletDataSubsetView'),\n    LeafletFeatureBuilder : require('./LeafletFeatureBuilder'),\n    // TemplateDataSetView : require('./TemplateDataSetView'),\n    // TemplateView : require('./TemplateView'),\n    // TemplateViewManager : require('./TemplateViewManager'),\n\n    ReactDataSetMixin : require('./ReactDataSetMixin'),\n    ViewManager : require('./ViewManager'),\n\n    URI : require('./URI')\n\n};\nmodule.exports = Mosaic;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mosaic-commons\"\n ** module id = 1\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar Intents = require('./Intents');\n\n/**\n * An application main class. It is the common superclass for all classes\n * implementing applications.\n */\nmodule.exports = Mosaic.Class.extend(Mosaic.Events.prototype, {\n\n    /** Constructor of this class. It initializes application modules. */\n    initialize : function(options) {\n        this.setOptions(options);\n        this.intents = new Intents();\n        this.initModules();\n    },\n\n    /**\n     * Starts the application. This method pre-loads initial data and activate\n     * views.\n     */\n    start : function() {\n        var that = this;\n        return Mosaic.P.then(function() {\n            return that.preloadData();\n        }).then(function() {\n            return that.initViews();\n        }, function(err) {\n            return that.initViews(err);\n        });\n    },\n\n    /** Stops this application and cleans up associated resources */\n    stop : function() {\n        var that = this;\n        return Mosaic.P.then(function() {\n            return that.deleteViews();\n        }).then(function() {\n            return that.deleteModules();\n        });\n    },\n\n    /**\n     * Pre-loads data for this application and optionally returns a promise with\n     * results.\n     */\n    preloadData : function() {\n    },\n\n    /**\n     * This function should load and initialize all modules of this application.\n     */\n    initModules : function() {\n    },\n\n    /** Removes modules of this applications. */\n    deleteModules : function() {\n    },\n\n    /**\n     * This method should initialize main views of this application. This method\n     * is called after initial application data are loaded. The specified error\n     * parameter is defined if there is an error while data loading. This method\n     * should visualize an error message in this case.\n     */\n    initViews : function(error) {\n    },\n\n    /** Closes all views of this application. */\n    deleteViews : function() {\n    }\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.js\n ** module id = 2\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar AppComponent = require('./App.Component');\n\n/** Common superclass for all stores */\nmodule.exports = AppComponent.extend({});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.Actions.js\n ** module id = 3\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar AppComponent = require('./App.Component');\nvar Mosaic = require('mosaic-commons');\nvar Teleport = require('mosaic-teleport');\n\n/**\n * An common super-class for all APIs objects. It contains some utility methods\n * used to load information from the server.\n */\nvar Api = AppComponent.extend({\n\n    /**\n     * Constructor of this class. Initializes the internal cache for data loaded\n     * from the server.\n     */\n    initialize : function(options) {\n        this.setOptions(options);\n        this.app = this.options.app;\n        this._initFields();\n        this.api = this._initApi(this.options.key);\n    },\n\n    // ------------------------------------------------------------------\n\n    /** Notifies subscribers about changes */\n    notify : function() {\n        this.emit('changed');\n    },\n\n    /** Adds a new change listener */\n    addChangeListener : function(listener, context) {\n        this.on('changed', listener, context);\n    },\n\n    /** Removes a change listener */\n    removeChangeListener : function(listener, context) {\n        this.off('changed', listener, context);\n    },\n\n    // ------------------------------------------------------------------\n\n    /**\n     * This method should initialize all internal fields of the store. It should\n     * be overloaded in subclasses.\n     */\n    _initFields : function() {\n    },\n\n    /**\n     * Initializes and returns an \"api\" field for this object. It replaces all\n     * methods marked with the \"intentHandler\" flag by an intent calls with the\n     * same name. The returned object contains all \"public\" methods (not started\n     * with the \"_\" symbol).\n     */\n    _initApi : function(key) {\n        var intents = this._getIntents();\n        var methods = this._getApiMethods();\n        this.api = intents.initApi(key, this, methods);\n        return this.api;\n    },\n\n    /**\n     * Returns a list of methods to expose in the 'api' object. Only these\n     * methods will be available from the outside of this object.\n     */\n    _getApiMethods : function() {\n        var methods = {};\n        _.each(_.functions(this), function(name) {\n            if (name[0] == '_') // Hide all \"private\" methods\n                return;\n            if (name.match(/^on.+$/)) // Hide all event handlers (onXxxx)\n                return;\n            methods[name] = true;\n        });\n        _.each(_.functions(AppComponent.prototype), function(name) {\n            delete methods[name];\n        }, this);\n        return _.keys(methods).sort();\n    },\n\n    /** Returns an Intents manager instance associated with this object. */\n    _getIntents : function() {\n        var intentsRegistry = this.intents || this.options.intents;\n        if (!intentsRegistry && this.app) {\n            intentsRegistry = this.app.intents;\n        }\n        return intentsRegistry;\n    },\n\n    /**\n     * Loads a set of GeoJSON arrays and merges them in one array. Returns a\n     * promise with the merged result.\n     */\n    _loadAndMergeGeoJsonArrays : function(urls) {\n        var that = this;\n        if (_.isString(urls)) {\n            urls = [ urls ];\n        } else {\n            urls = _.toArray(urls);\n        }\n        return Mosaic.P.all(_.map(urls, function(url) {\n            return that._loadGeoJsonArray(url);\n        })).then(function(list) {\n            var result = [];\n            _.each(list, function(array) {\n                result = result.concat(array);\n            });\n            return result;\n        });\n    },\n\n    /**\n     * This method loads a GeoJSON object and transforms it to an array. Returns\n     * a promise for the resulting array. Internally it calls the \"_getJson\"\n     * method, so all parameters of the \"_getJson\" method are applicable for\n     * this method as well.\n     */\n    _getGeoJsonArray : function(options) {\n        return this._getJson(options).then(toArray);\n    },\n\n    /**\n     * This method loads a GeoJSON object and transforms it to an array. Returns\n     * a promise for the resulting array. Internally it calls the \"_loadJson\"\n     * method, so all parameters of the \"_loadJson\" method are applicable for\n     * this method as well.\n     */\n    _loadGeoJsonArray : function(options) {\n        var path = _.isString(options) ? options : options.path;\n        return this._loadJson(path).then(toArray);\n    },\n\n    /**\n     * This method returns a promise for a JSON object loaded from the server\n     * using internal cache (if the specified options does not contain \"noCache\"\n     * or \"force\" flags). If the cache does not contain objects for the\n     * specified flag then this method calls the \"_loadJson\" method to fetch\n     * data from the server and puts the result in the cache for the future\n     * re-use (if no \"noCache\" flag is defined in the method parameters).\n     * \n     * @param options.path\n     *                (mandatory) path of the data to load\n     * @param options.force\n     *                with this flag this method forces data re-loading from the\n     *                server; the result of this operation is stored in the\n     *                internal cache (if no \"noCache\" flag defined)\n     * @param options.noCache\n     *                if this flag is defined then data are loaded from the\n     *                server and not stored in the internal cache; with this\n     *                flag this method just calls the \"_loadJson\" method\n     * @return a promise with the JSON object loaded from the server\n     */\n    _getJson : function(options) {\n        var that = this;\n        return Mosaic.P.then(function() {\n            var path = options.path;\n            var noCache = options.noCache;\n            var forceReload = options.force;\n            var result;\n            var cache = that._cache = that._cache || {};\n            if (!noCache && !forceReload) {\n                result = cache[path];\n            }\n            if (result) {\n                return result;\n            }\n            return that._loadJson(path).then(function(result) {\n                if (!noCache) {\n                    cache[path] = result;\n                }\n                return result;\n            });\n        });\n    },\n\n    /**\n     * Loads a JSON object from the server using the specified path. The baseUrl\n     * parameter for this operation is taken from application options.\n     * \n     * @param path\n     *                path to the JSON data on the server\n     * @return a promise with the result of the loading operation\n     */\n    _loadJson : function(path) {\n        var that = this;\n        return Mosaic.P.then(function() {\n            var baseUrl = that.app.options.baseUrl;\n            var client = Teleport.HttpClient.newInstance({\n                baseUrl : baseUrl\n            });\n            return client.exec({\n                path : path,\n                method : 'GET'\n            });\n        });\n    },\n\n});\n\nApi.intent = function(m) {\n    m.intentHandler = true;\n    return m;\n};\n\nfunction toArray(obj) {\n    if (!obj)\n        return obj;\n    if (_.isArray(obj))\n        return obj;\n    if (_.isArray(obj.features)) {\n        return obj.features;\n    }\n    return obj;\n}\n\nApi.toArray = toArray;\n\nmodule.exports = Api;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.Api.js\n ** module id = 4\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\n\n/**\n * An application component. It is the common superclass for all classes using\n * the application as an execution context.\n */\nmodule.exports = Mosaic.Class.extend(Mosaic.Events.prototype, {\n\n    initialize : function(options) {\n        this.setOptions(options);\n        this.app = this.options.app;\n    },\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.Component.js\n ** module id = 5\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar AppComponent = require('./App.Component');\n\n/** Common superclass for all stores */\nmodule.exports = AppComponent.extend({\n\n    /**\n     * Overloads the parent 'setOptions' method to set the application in the\n     * 'app' field of this object.\n     */\n    setOptions : function(options) {\n        AppComponent.prototype.setOptions.apply(this, arguments);\n        if (this.options.app) {\n            this.app = this.options.app;\n        }\n    },\n\n    /**\n     * Declares new actions (intents) on this store. All actions are available\n     * on the \"action\" field of this store.\n     */\n    _addActions : function(actions) {\n        var that = this;\n        if (!that.actions) {\n            that.actions = {};\n        }\n        _.each(actions, function(action) {\n            that.actions[action] = function(options) {\n                return that.app.intents.newIntent(action, options).promise;\n            };\n        });\n    },\n\n    /** Initializes this object. */\n    initialize : function(options) {\n        this.setOptions(options);\n        this._initFields();\n    },\n\n    /** Notifies subscribers about changes */\n    notify : function() {\n        this.emit('changed');\n    },\n    /** Adds a new change listener */\n    addChangeListener : function(listener, context) {\n        this.on('changed', listener, context);\n    },\n    /** Removes a change listener */\n    removeChangeListener : function(listener, context) {\n        this.off('changed', listener, context);\n    },\n\n    /**\n     * This method should initialize all internal fields of the store. It should\n     * be overloaded in subclasses.\n     */\n    _initFields : function() {\n    },\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.Store.js\n ** module id = 6\n ** module chunks = 0\n **/","var _ = require('underscore');\r\nvar Mosaic = require('mosaic-commons');\r\nvar React = require('react');\r\n\r\n/**\r\n * Datamodel for the FilterBox component providing access to values to\r\n * visualize.\r\n */\r\nvar FilterBoxModel = Mosaic.Class.extend(Mosaic.Events.prototype, {\r\n\r\n    initialize : function(options) {\r\n        this.values = [];\r\n        _.extend(this, options);\r\n    },\r\n    /** Sets a new list of value objects. */\r\n    set : function(values, notify) {\r\n        if (!_.isArray(values)) {\r\n            values = [];\r\n        }\r\n        this.values = values;\r\n        this._notify('set');\r\n        return this;\r\n    },\r\n    /** Returns a list of existing values. */\r\n    getAll : function() {\r\n        return this.values;\r\n    },\r\n    /** Adds a new text and creates a new tag object. */\r\n    add : function(text) {\r\n        this.values.push(this.newFilterValue(text));\r\n        this._notify('add');\r\n        return this;\r\n    },\r\n    /** Removes the specified value from the list. */\r\n    remove : function(tag) {\r\n        var len = this.values.length;\r\n        this.values = _.filter(this.values, function(t) {\r\n            return (t != tag);\r\n        });\r\n        if (this.values.length != len) {\r\n            this._notify('remove');\r\n        }\r\n        return this;\r\n    },\r\n    newFilterValue : function(text) {\r\n        return {\r\n            label : text\r\n        };\r\n    },\r\n    /** Updates focused status of the underlying input box. */\r\n    setFocused : function(focused, silent) {\r\n        var changed = false;\r\n        if (this._focused === focused) {\r\n            return;\r\n        }\r\n        changed = true;\r\n        this._focused = focused;\r\n        if (!silent) {\r\n            this.emit('focus', this._focused);\r\n        }\r\n    },\r\n    /** Returns <code>true</code> if the input is focused. */\r\n    isFocused : function() {\r\n        return !!this._focused;\r\n    },\r\n    /** Notifies subscribers about changes */\r\n    _notify : function(evt) {\r\n        if (evt) {\r\n            this.emit(evt);\r\n        }\r\n        this.emit('changed');\r\n        return this;\r\n    },\r\n    /** Adds a new change listener */\r\n    addChangeListener : function(listener, context) {\r\n        this.on('changed', listener, context);\r\n        return this;\r\n    },\r\n    /** Removes a change listener */\r\n    removeChangeListener : function(listener, context) {\r\n        this.off('changed', listener, context);\r\n        return this;\r\n    },\r\n});\r\n\r\n/**\r\n * Allows to manage filtering boxes where filter criteria are added as tags to\r\n * the list. This class expects the following parameters in the constructor:\r\n * \r\n * @param model\r\n *                the model object with the following fields/methods:\r\n * @param model.getAll\r\n *                this method returns all values in this filter\r\n * @param model.add\r\n *                this method adds a new text value to the filter list\r\n * @param model.remove\r\n *                removes the specified object from the internal list\r\n * @param model.set\r\n *                sets a new values; new values replace the old one\r\n */\r\nmodule.exports = React.createClass({\r\n    displayName : 'React.FilterBox',\r\n    statics : {\r\n        Model : FilterBoxModel,\r\n        extendModel : function(options) {\r\n            return FilterBoxModel.extend(options);\r\n        }\r\n    },\r\n    /** Returns the initial state for this input box. */\r\n    getInitialState : function() {\r\n        return this._newState({});\r\n    },\r\n    /** This method registers an API listener. */\r\n    componentWillMount : function() {\r\n        this.props.model.addChangeListener(this._notifyUpdates);\r\n    },\r\n    /** Removes the registered API listener. */\r\n    componentWillUnmount : function() {\r\n        this.props.model.removeChangeListener(this._notifyUpdates);\r\n    },\r\n    componentDidMount : function() {\r\n        this.componentDidUpdate();\r\n    },\r\n    componentDidUpdate : function() {\r\n        if (this.props.model.isFocused()) {\r\n            var input = this.refs.input;\r\n            var node = input.getDOMNode();\r\n            node.focus();\r\n        }\r\n    },\r\n    /** Updates this view when model properties were changed. */\r\n    _notifyUpdates : function() {\r\n        this.setState(this._newState({\r\n            text : ''\r\n        }));\r\n        this.props.model.setFocused(true);\r\n    },\r\n    /** Returns a new state. */\r\n    _newState : function(options) {\r\n        var model = this.props.model;\r\n        return _.extend({\r\n            text : '',\r\n            values : model.getAll()\r\n        }, this.state, options);\r\n    },\r\n    /** Sets the specified value as a search criteria and activates search */\r\n    _addValue : function(value) {\r\n        if (value && value !== '') {\r\n            this.props.model.add(value);\r\n        }\r\n    },\r\n    /** Removes the last tag */\r\n    _removeLastValue : function() {\r\n        var model = this.props.model;\r\n        var all = model.getAll();\r\n        if (all && all.length) {\r\n            model.remove(all[all.length - 1]);\r\n        }\r\n    },\r\n    /**\r\n     * This handler is called when user clicks on the FilterBox DOM node to\r\n     * focus the input box.\r\n     */\r\n    _focusInput : function(ev) {\r\n        this.props.model.setFocused(true);\r\n        this.forceUpdate();\r\n    },\r\n    /**\r\n     * Handles input box focusing. Changes the visualization styles for the\r\n     * FilterBox.\r\n     */\r\n    _handleInputFocus : function(ev) {\r\n        this.props.model.setFocused(true);\r\n    },\r\n    /**\r\n     * Handles input box blurring. Changes the visualization styles for the\r\n     * FilterBox.\r\n     */\r\n    _handleInputBlur : function(ev) {\r\n        this._addValue(this.state.text);\r\n        this.props.model.setFocused(false, true);\r\n    },\r\n\r\n    /**\r\n     * Handles modifications of the input box.\r\n     */\r\n    _handleInputChange : function(ev) {\r\n        // ev.preventDefault();\r\n        // ev.stopPropagation();\r\n        var input = this.refs.input.getDOMNode();\r\n        var value = input.value;\r\n        var size = this._getInputSize(value);\r\n        input.size = size;\r\n        this.setState(this._newState({\r\n            text : value\r\n        }));\r\n    },\r\n    /**\r\n     * Handles events when user push keyboard button. It updates the text value\r\n     * when user press Enter.\r\n     */\r\n    _handleKeyDown : function(ev) {\r\n        var clear = false;\r\n        if (ev.which === 9) { // Tab\r\n            this._addValue(this.state.text);\r\n            this.props.model.setFocused(true);\r\n            clear = true;\r\n        } else if (ev.which === 8 && this.state.text === '') { // Del\r\n            this._removeLastValue();\r\n            clear = true;\r\n        } else if (ev.which === 13) { // Enter\r\n            this._addValue(this.state.text);\r\n            if (this.props.onSubmit) {\r\n                this.props.onSubmit(ev);\r\n            }\r\n            clear = true;\r\n        } else if (ev.which == 27) { // Esc\r\n            clear = true;\r\n        }\r\n        if (clear) {\r\n            this.setState(this._newState({\r\n                text : ''\r\n            }));\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n        }\r\n    },\r\n    /**\r\n     * This method is called when user clicks on already existing node.\r\n     */\r\n    _handleItemClick : function(item, ev) {\r\n        this.props.model.remove(item);\r\n        ev.preventDefault();\r\n        ev.stopPropagation();\r\n    },\r\n    /** Formats and returns all tags */\r\n    _formatTags : function() {\r\n        var model = this.props.model;\r\n        return _.map(model.getAll(), function(val) {\r\n            if (_.isFunction(val.format)) {\r\n                return val.format();\r\n            } else {\r\n                var className = 'item tag';\r\n                if (val.className) {\r\n                    className += ' ' + val.className;\r\n                }\r\n                return (React.DOM.a({\r\n                    key : _.uniqueId('id-'),\r\n                    href : \"#\",\r\n                    className : className,\r\n                    onClick : this._handleItemClick.bind(this, val),\r\n                }, val.label, React.DOM.span({\r\n                    key : _.uniqueId('id-'),\r\n                    className : 'cross',\r\n                    onClick : this._handleItemClick.bind(this, val),\r\n                })));\r\n                \r\n                \r\n                \r\n            }\r\n        }, this);\r\n    },\r\n    /** Main rendering method of this class. */\r\n    render : function() {\r\n        var app = this.props.app;\r\n        var cssClass = this.props.className || 'filter-box';\r\n        if (this.props.model.isFocused()) {\r\n            cssClass += ' focused';\r\n        }\r\n        var value = this.state.text;\r\n        var inputSize = this._getInputSize(value);\r\n        return (React.DOM.div(_.extend({}, this.props.options, {\r\n            onClick : this._focusInput,\r\n            className : cssClass\r\n        }), this._formatTags(), React.DOM.input(_.extend({\r\n            className : 'item'\r\n        }, this.props.inputOptions, {\r\n            ref : 'input',\r\n            size : inputSize,\r\n            type : 'text',\r\n            onFocus : this._handleInputFocus,\r\n            onBlur : this._handleInputBlur,\r\n            onChange : this._handleInputChange,\r\n            onKeyDown : this._handleKeyDown,\r\n            value : value\r\n        }))));\r\n    },\r\n    /** Returns the size of the input box. */\r\n    _getInputSize : function(value) {\r\n        value = value || '';\r\n        return Math.min(50, Math.max(value.length, 3));\r\n    }\r\n});\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/React.FilterBox.js\n ** module id = 7\n ** module chunks = 0\n **/","var _ = require('underscore');\r\nvar React = require('react');\r\nvar Mosaic = require('mosaic-commons');\r\nvar FilterBox = require('./React.FilterBox');\r\n\r\nvar SearchBoxMixinModel = FilterBox.extendModel({\r\n\r\n    /**\r\n     * Converts a search criteria object into a list of values accepted by the\r\n     * filter box.\r\n     */\r\n    _convertSearchToFilters : function(criteria) {\r\n        var values = [];\r\n        _.map(criteria, function(value, key) {\r\n            if (_.isArray(value)) {\r\n                _.each(value, function(val) {\r\n                    values.push(this.newFilterValue(val, key));\r\n                }, this);\r\n            } else {\r\n                values.push(this.newFilterValue(value, key));\r\n            }\r\n        }, this);\r\n        return values;\r\n    },\r\n\r\n    /** Converts filter box values in a search criteria object. */\r\n    convertFiltersToSearch : function(values) {\r\n        var result = {};\r\n        _.each(values, function(val) {\r\n            var key = val.key;\r\n            var criteria = this.newSearchValue(val, key);\r\n            if (!_.has(result, key)) {\r\n                result[key] = [ criteria ];\r\n            } else {\r\n                var arr = result[key];\r\n                arr.push(criteria);\r\n            }\r\n        }, this);\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns a new filter value object used by filter box to show\r\n     * values. This function overloads a method with the same name from the\r\n     * FilterBox.Model class.\r\n     */\r\n    newFilterValue : function(value, key) {\r\n        return {\r\n            key : key || this.getDefaultField(),\r\n            label : value\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Converts a filter value to a search criteria.\r\n     */\r\n    newSearchValue : function(value, key) {\r\n        return value.label;\r\n    },\r\n\r\n    /**\r\n     * Returns the name of the default text search field.\r\n     */\r\n    getDefaultField : function() {\r\n        return this.textSearchField || 'q';\r\n    },\r\n\r\n});\r\n\r\n/**\r\n * This mixin expects that the following methods and fields are implemented in\r\n * the parent class: 1) '_onSearchCriteriaChanged' - this method is used to set\r\n * changed search criteria object 2) 'this.state.textSearchField' should contain\r\n * the name of the search field associated with the text entered by user. The\r\n * following methods should be used to interact with the internal state of the\r\n * filter box: 'setSearchCriteria' method should be used to update the search\r\n * criteria; the 'getSearchCriteria' method returns all search criteria managed\r\n * by the filter box; the 'renderSearchBox' returns a new rendered search box\r\n */\r\nvar SearchBoxMixin = {\r\n\r\n    Model : SearchBoxMixinModel,\r\n\r\n    /** Registers new filters the internal box model. */\r\n    componentWillMount : function() {\r\n        var model = this._getFilterBoxModel();\r\n        model.on('add', this._onFilterBoxChanged, this);\r\n        model.on('remove', this._onFilterBoxChanged, this);\r\n    },\r\n\r\n    /** Removes filter all listeners of the internal box model. */\r\n    componentDidUnmount : function() {\r\n        var model = this._getFilterBoxModel();\r\n        model.off('add', this._onFilterBoxChanged, this);\r\n        model.off('remove', this._onFilterBoxChanged, this);\r\n        delete this._model;\r\n    },\r\n    /**\r\n     * Converts a search criteria object into a list of values accepted by the\r\n     * filter box.\r\n     */\r\n    _convertSearchToFilters : function(criteria) {\r\n        var model = this._getFilterBoxModel();\r\n        return model._convertSearchToFilters(criteria);\r\n    },\r\n    /** Converts filter box values in a search criteria object. */\r\n    _convertFiltersToSearch : function(values) {\r\n        var model = this._getFilterBoxModel();\r\n        return model.convertFiltersToSearch(values);\r\n    },\r\n\r\n    /** Returns an underlying model keeping values for a filter box. */\r\n    _getFilterBoxModel : function() {\r\n        var that = this;\r\n        if (!that._model) {\r\n            if (_.isFunction(that._newFilterModel)) {\r\n                that._model = that._newFilterModel();\r\n            } else {\r\n                that._model = new SearchBoxMixinModel();\r\n            }\r\n        }\r\n        return that._model;\r\n    },\r\n    /** An internal method handling changes of values in the filter box. */\r\n    _onFilterBoxChanged : function() {\r\n        var criteria = this.getSearchCriteria();\r\n        this._onSearchCriteriaChanged(criteria);\r\n    },\r\n    /** Sets a new search criteria object to reflect in the filter box. */\r\n    setSearchCriteria : function(searchCriteria) {\r\n        var model = this._getFilterBoxModel();\r\n        var values = this._convertSearchToFilters(searchCriteria);\r\n        model.set(values);\r\n    },\r\n    /** Returns an object containing search criteria. */\r\n    getSearchCriteria : function() {\r\n        var model = this._getFilterBoxModel();\r\n        var values = model.getAll();\r\n        var criteria = this._convertFiltersToSearch(values);\r\n        return criteria;\r\n    },\r\n    /**\r\n     * This method renders and returns a filter box using the underlying model\r\n     * keeping the state of the search box.\r\n     */\r\n    renderSearchBox : function(options) {\r\n        return (FilterBox(_.extend({}, options, {\r\n            model : this._getFilterBoxModel()\r\n        })));\r\n    },\r\n};\r\n\r\nmodule.exports = SearchBoxMixin;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/React.SearchBoxMixin.js\n ** module id = 8\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar React = require('react');\nvar L = require('leaflet');\n\nmodule.exports = React.createClass({\n    displayName : 'ReactMap',\n    render : function() {\n        return (React.DOM.div({\n            ref : 'container',\n            id : this.props.id,\n            className : this.props.className\n        }));\n    },\n    componentDidMount : function() {\n        var container = this.refs.container.getDOMNode();\n        this.map = this._newMap(container);\n        this.map.on('zoomend', this._updateZoomStyles, this);\n        if (this.props.onMapAdd) {\n            this.props.onMapAdd(this.map);\n        }\n        this._updateZoomStyles();\n    },\n    componentWillUnmount : function() {\n        if (this.props.onMapRemove) {\n            this.props.onMapRemove(this.map);\n        }\n        this.map.off('zoomend', this._updateZoomStyles, this);\n        this.map.remove();\n        delete this.map;\n    },\n    _newMap : function(container) {\n        var mapOptions = this.props.options || {};\n        var options = _.extend({}, mapOptions, {\n            zoomControl : false,\n            attributionControl : false,\n        });\n        var map = L.map(container, options);\n        options = _.extend({}, mapOptions.zoomControl);\n        options = _.defaults(options, {\n            position : 'topright'\n        });\n\n        // Set the initial view of this map\n        if (mapOptions.zoomControl !== false) {\n            var zoomControl = L.control.zoom(options);\n            map.addControl(zoomControl);\n        }\n\n        if (mapOptions.attributionControl !== false) {\n            var attributionControl = L.control.attribution(options);\n            map.addControl(attributionControl);\n        }\n\n        var center = mapOptions.center;\n        if (_.isArray(center)) {\n            center = L.latLng(center[1], center[0]);\n        }\n        var zoom = mapOptions.zoom;\n        if (center && zoom !== undefined) {\n            map.setView(center, zoom);\n        }\n        return map;\n    },\n    _updateZoomStyles : function() {\n        var node = this.getDOMNode();\n        var zoom = this.map.getZoom();\n        var cls = [];\n        for (var i = 0; i <= zoom; i++) {\n            cls.push('zoom-' + i);\n        }\n        var css = node.className;\n        css = css.replace(/zoom-\\d+\\s*/gim, '');\n        css += ' ' + cls.join(' ');\n        node.className = css;\n    }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LeafletReactMap.js\n ** module id = 9\n ** module chunks = 0\n **/","var L = require('leaflet');\r\nvar Mosaic = require('mosaic-commons');\r\n\r\nvar Config = Mosaic.Class.extend({\r\n\r\n    initialize : function(data, options) {\r\n        if (!options) {\r\n            options = data;\r\n            data = null;\r\n        }\r\n        this.data = data;\r\n        _.extend(this, options);\r\n        var methods = [ 'onClick', 'onMouseOver', 'onMouseOut', 'onDblClick',\r\n                'onMouseMove' ];\r\n        this._handlers = {};\r\n        _.each(methods, function(m) {\r\n            var key = m.toLowerCase().substring(2);\r\n            this[m] = function(handler) {\r\n                if (handler !== undefined) {\r\n                    this._handlers[key] = handler;\r\n                    return this;\r\n                } else {\r\n                    return this._handlers[key];\r\n                }\r\n            };\r\n        }, this);\r\n    },\r\n\r\n    setEventBinder : function(method) {\r\n        this.bindEventHandlers = method;\r\n        return this;\r\n    },\r\n\r\n    bindEventHandlers : function(data, layer) {\r\n        var that = this;\r\n        _.each(that._handlers, function(handler, event) {\r\n            layer.on(event, function(ev) {\r\n                handler(data, ev);\r\n            });\r\n        });\r\n    },\r\n\r\n    setOptions : function(opt) {\r\n        this.opt = opt;\r\n        return this;\r\n    },\r\n\r\n    getOptions : function() {\r\n        var args = _.toArray(arguments);\r\n        return this._getOrInvoke(this.opt, args) || {};\r\n    },\r\n\r\n    setMarker : function(m) {\r\n        this._marker = m;\r\n        return this;\r\n    },\r\n\r\n    getMarker : function() {\r\n        var args = _.toArray(arguments);\r\n        return this._getOrInvoke(this._marker, args);\r\n    },\r\n\r\n    build : function(data) {\r\n        var that = this;\r\n        data = data || that.data;\r\n        var geom = data.geometry;\r\n        if (that._isEmptyGeometry(geom)) {\r\n            return null;\r\n        }\r\n        var options = that.getOptions(data);\r\n        var marker;\r\n        var layer = L.GeoJSON.geometryToLayer(data, function(resource, latlng) {\r\n            marker = that.getMarker(resource, options);\r\n            if (marker === undefined) {\r\n                marker = new L.Marker(latlng, options);\r\n            }\r\n            return marker;\r\n        }, L.GeoJSON.coordsToLatLng, options);\r\n        if (layer && !marker) {\r\n            marker = that.getMarker(data, options);\r\n            if (marker) {\r\n                layer = L.featureGroup([ layer, marker ]);\r\n            }\r\n        }\r\n        this.bindEventHandlers(data, layer);\r\n        return layer;\r\n    },\r\n\r\n    _getOrInvoke : function(val, args) {\r\n        if (_.isFunction(val)) {\r\n            return val.apply(val, args);\r\n        } else {\r\n            return val;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns <code>true</code> if the specified geometry is empty.\r\n     */\r\n    _isEmptyGeometry : function(geom) {\r\n        if (!geom || !geom.coordinates || //\r\n        !geom.coordinates.length)\r\n            return true;\r\n        if (geom.type == 'Point') {\r\n            if (!geom.coordinates[0] || !geom.coordinates[1])\r\n                return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n});\r\n\r\nvar LeafletFeatureBuilder = function(data, options) {\r\n    return new Config(data, options);\r\n};\r\n\r\nmodule.exports = LeafletFeatureBuilder;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LeafletFeatureBuilder.js\n ** module id = 10\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar L = require('leaflet');\nvar InteractionLayer = require('./Leaflet.InteractionLayer');\n\n/**\n * The code of this class was mostly copied from the leaflet.utfgrid Leaflet\n * extension (MIT license, by David Leaver). The difference with the original\n * implementation is that 1) this class delegates tiles\n * loading/caching/canceling operations to an MapTilesLoader instance; 2) this\n * class notifies about loading of tiles for each new screen using the\n * \"startLoading\"/\"endLoading\" events; 3) it loads tiles starting from the\n * center of the current screen.\n */\nvar UtfGrid = InteractionLayer.extend({\n\n    /** Initializes this layer */\n    initialize : function(options) {\n        var parent = InteractionLayer.prototype;\n        parent.initialize.call(this, options);\n        _.defaults(this.options, {\n            resolution : 4,\n            pointerCursor : true\n        });\n        this._loader = this.options.loader || //\n        new MapTilesLoader(this.options);\n    },\n    /**\n     * Returns an object from UTF grid corresponding to the coordinates of the\n     * mouse event.\n     */\n    _objectForEvent : function(e) {\n        var map = this._map;\n        var zoom = map.getZoom();\n        var point = map.project(e.latlng);\n        var pos = this._getTilePosition(point);\n\n        var tile = this._loader.getTile(zoom, pos);\n        var result;\n        if (tile) {\n            result = this._getTileObject(tile, point);\n        }\n\n        return {\n            latlng : e.latlng,\n            data : result\n        };\n    },\n\n    /**\n     * Returns an object from the specified tile corresponding to the given\n     * position.\n     */\n    _getTileObject : function(tile, point) {\n        var gridX = this._getTileShift(point.x);\n        var gridY = this._getTileShift(point.y);\n        var idx = this._utfDecode(tile.grid[gridY].charCodeAt(gridX));\n        var key = tile.keys[idx];\n        var result = this._processData(tile.data[key]);\n        return result;\n    },\n\n    /**\n     * Returns a list of all objects contained in the specified UTFGrid tile.\n     */\n    getTileObjects : function(tile) {\n        return tile && tile.data ? _.map(_.values(tile.data),\n                this._processData, this) : [];\n    },\n\n    /**\n     * Pre-process individual data object before returning it to the caller.\n     */\n    _processData : function(data) {\n        if (!data)\n            return data;\n        if (!this._processDataF) {\n            this._processDataF = this.options.processData || //\n            function(data) {\n                return data;\n            };\n        }\n        return this._processDataF(data);\n    },\n\n    /**\n     * Returns position of the specified coordinates in a tile\n     */\n    _getTileShift : function(val) {\n        var tileSize = this.options.tileSize;\n        var resolution = this.options.resolution;\n        return Math.floor((val - (Math.floor(val / tileSize) * tileSize)) / //\n        resolution);\n    },\n\n    /**\n     * Decodes the specified character and transforms it in an index\n     */\n    _utfDecode : function(ch) {\n        if (ch >= 93) {\n            ch--;\n        }\n        if (ch >= 35) {\n            ch--;\n        }\n        return ch - 32;\n    }\n\n});\n\nmodule.exports = UtfGrid;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Leaflet.UtfGrid.js\n ** module id = 11\n ** module chunks = 0\n **/","var L = require('leaflet');\n\n/**\n * This class provides common utility methods to manage specific geographic zone\n * as the main viewport. It means that all operations like fitBounds(bounds) or\n * setView(latlng, zoom) will takes into account the specified map zone and not\n * the whole map.\n */\nvar MapViewport = L.Class.extend({\n\n    /**\n     * Initializes this object.\n     * \n     * @param options.map\n     *                the Leaflet map object\n     * @param options.viewport\n     *                a L.Bounds instance defining the main visible zone on the\n     *                map; see the #setViewport method\n     * @param options.focus\n     *                focus position on the map; when user uses #focusTo method\n     *                then the specified lat/lng point is moved in the given\n     *                position on the screen\n     */\n    initialize : function(options) {\n        L.setOptions(this, options);\n        var viewport = this.options.viewport;\n        if (viewport) {\n            this.setViewport(viewport);\n        }\n        if (this.options.focus) {\n            this.setFocusPosition(this.options.focus);\n        }\n    },\n\n    /**\n     * Returns the map managed by this class. By default this method returns the\n     * \"options.map\".\n     */\n    getMap : function() {\n        return this.options.map;\n    },\n\n    /**\n     * Defines the viewport for the map - the visible area of the map where data\n     * should be focused and fitted. If a focus position is not defined then\n     * this method sets the focus position to the center of the specified\n     * viewport area.\n     * \n     * @param viewport\n     *                a L.Bounds instance defining the main visible zone on the\n     *                map; this object defines top, right, left and bottom shift\n     *                of the viewport on the visible map screen area\n     */\n    setViewport : function(viewport) {\n        this._viewport = L.bounds(viewport);\n        if (!this._focusPos) {\n            this._focusPos = this._viewport.getCenter();\n        }\n    },\n\n    /**\n     * Returns the current viewport for the underlying map\n     */\n    getViewport : function() {\n        if (this._viewport)\n            return this._viewport;\n        var map = this.getMap();\n        return L.bounds([ 0, 0 ], map.getSize());\n    },\n\n    /**\n     * Defines position on the map (in pixels) where map should be moved when\n     * user tries to set view or focus on a specific geographic position.\n     * \n     * @param options.focus\n     *                focus position on the map; when user uses #focusTo method\n     *                then the specified lat/lng point is moved in the given\n     *                position on the screen\n     */\n    setFocusPosition : function(pos) {\n        this._focusPos = L.point(pos.left, pos.top);\n    },\n\n    /**\n     * Moves the map to the specified geographic position. If a focus position\n     * is specified the requested geographic position is moved in this pixel\n     * position on the map screen area. Otherwise the focus position defined by\n     * the \"setFocusPosition\" is used.\n     */\n    focusTo : function(coords, focusPos, callback) {\n        var that = this;\n        if (typeof focusPos === 'function') {\n            callback = focusPos;\n            focusPos = null;\n        }\n        callback = this._checkCallback(callback);\n        var map = this.getMap();\n        focusPos = focusPos || this._focusPos;\n        map.once('moveend', callback);\n        if (focusPos) {\n            var focus = map._getTopLeftPoint();\n            focus._add(focusPos);\n            var shift = map.project(coords).subtract(focus);\n            map.panBy(shift);\n        } else {\n            map.panTo(coords);\n        }\n    },\n\n    /**\n     * This method performs zoom (if necessary) and calls the specified callback\n     * method. It is useful to be sure that the callback is really invoked\n     * (which is not the case with the 'zoomend' Leaflet event).\n     */\n    zoomTo : function(zoom, callback) {\n        var map = this.getMap();\n        callback = this._checkCallback(callback);\n        if (map.getZoom() == zoom) {\n            callback();\n        } else {\n            map.once('zoomend', callback);\n            map.setZoom(zoom);\n        }\n    },\n\n    /**\n     * Zooms and moves the map viewport to fit in the specified geographic\n     * bounds.\n     */\n    panInsideBounds : function(bounds, callback) {\n        var that = this;\n        var map = that.getMap();\n        callback = that._checkCallback(callback);\n        var padding = that._getViewportPadding();\n        var zoom = map.getBoundsZoom(bounds, true, padding);\n        that.zoomTo(zoom, function() {\n            var focusPos = that._focusPos;\n            var newCenter = map._limitCenter(focusPos, zoom, bounds);\n            if (!center.equals(newCenter)) {\n                that.focusTo(newCenter, callback);\n            } else {\n                callback();\n            }\n        });\n    },\n\n    /**\n     * This method fits the specified geographic bounds in the currently defined\n     * viewport area.\n     */\n    fitBounds : function(bounds) {\n        var viewport = this.getViewport();\n        var padding = this._getViewportPadding();\n        var options = {};\n        options.paddingTopLeft = padding.min;\n        options.paddingBottomRight = padding.max;\n        var map = this.getMap();\n        map.fitBounds(bounds, options);\n    },\n\n    /** Checks the specified function and returns a non-empty callback. */\n    _checkCallback : function(callback) {\n        return callback || function() {\n        };\n    },\n\n    /**\n     * An internal utility method returning the distance from the map bounds and\n     * the viewport area.\n     */\n    _getViewportPadding : function() {\n        var viewport = this.getViewport();\n        var min = viewport.min;\n        var map = this.getMap();\n        var size = map.getSize();\n        var max = size.subtract(viewport.max);\n        return L.bounds(min, max);\n    },\n\n});\n\nmodule.exports = MapViewport;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LeafletMapViewport.js\n ** module id = 12\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar AbstractSet = require('./AbstractSet');\nvar _ = require('underscore');\n\n/**\n * This class represents a data set. Each dataset manages a set of objects with\n * unique keys. The \"setData\" of this class accepts an array of objects and\n * sends notifications about changes with this data set to the registered\n * listener. This listener could be registered using the \"setListener\" method or\n * it can be defined as a parameter of the class constructor.\n */\nvar DataSet = AbstractSet.extend({\n\n    /**\n     * Class constructor.\n     * \n     * @param options.getId\n     *                this optional method is used to retrieve object\n     *                identifiers\n     */\n    initialize : function(options) {\n        AbstractSet.prototype.initialize.apply(this, arguments);\n        this._open = false;\n    },\n\n    /**\n     * Opens this data set - registeres data set listeners and sets the initial\n     * data.\n     */\n    open : function() {\n        if (this._open)\n            return false;\n        this.triggerMethod('open');\n        if (this.options.data) {\n            this.setData(this.options.data);\n        }\n        this._open = true;\n        return true;\n    },\n\n    /** Closes this dataset. It removes all registered listeners. */\n    close : function() {\n        if (!this._open)\n            return false;\n        this.setData([]);\n        this.triggerMethod('close');\n        this._open = false;\n        return true;\n    },\n\n    /**\n     * Sets a new array of objects and generates an \"update\" event containing\n     * the \"enter\", \"exit\" and \"update\" indexes; each index contains keys and\n     * the corresponding index entries with \"key\", \"obj\" and \"idx\" fields (where\n     * \"key\" is the key of the object; \"obj\" the object itself and \"idx\" the\n     * index of this object in the list). This method returns reference to this\n     * instance to allow methods call chaining.\n     */\n    setData : function(data) {\n        this.triggerMethod('update:begin');\n        var event = this._setObjects(data);\n        this.triggerMethod('update', event);\n        this.triggerMethod('update:end');\n        return this;\n    },\n\n    /**\n     * This method returns an object with the specified key or the full array of\n     * all objects if such a key is not defined.\n     */\n    getData : function(key) {\n        if (key) {\n            var entry = this._index[key];\n            return entry ? entry.obj : null;\n        } else {\n            return _.map(this._index, function(entry) {\n                return entry.obj;\n            });\n        }\n    },\n\n    /**\n     * This method returns an index entries containing the data, the\n     * corresponding key and position of the data object in the array.\n     */\n    getDataEntries : function(key) {\n        if (key) {\n            var entry = this._index[key];\n            return entry;\n        } else {\n            return _.values(this._index);\n        }\n    },\n\n    /** Returns position of the specified entity in this dataset. */\n    getDataIndex : function(d) {\n        var key = this.getKey(d);\n        return this.getIndex(key);\n    },\n\n});\n\nmodule.exports = DataSet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataSet.js\n ** module id = 13\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\n/* ------------------------------------------------- */\n\n/**\n * Tree structure.\n */\nvar TreeNode = Mosaic.Class.extend(//\nMosaic.Events.prototype, Mosaic.Events, {\n\n    /** Initializes this class */\n    initialize : function(options) {\n        this.setOptions(options);\n        this._children = {};\n    },\n\n    /** Returns path from this node to the specified top node. */\n    getPath : function(top) {\n        var path = '';\n        var node = this;\n        while (node && node != top) {\n            path = '/' + node.getKey() + path;\n            node = node.getParent();\n        }\n        return path;\n    },\n\n    /** Returns a parent for this node. */\n    getParent : function() {\n        return this.parent;\n    },\n\n    /** Returns a key associated with this tree node */\n    getKey : function() {\n        return this.options.key;\n    },\n\n    /**\n     * Adds the specified subnode to this tree node. If the subnode is not\n     * defined then a new one is created and returned.\n     */\n    add : function(key, node) {\n        var that = this;\n        if (!node && _.isObject(key)) {\n            node = key;\n        }\n        if (_.isFunction(key.getKey)) {\n            key = key.getKey();\n        }\n        that.remove(key);\n        if (!node) {\n            node = that._newChild(key);\n        }\n        node.parent = this;\n        that._children[key] = node;\n        node._notify('add', {});\n        return node;\n    },\n\n    /**\n     * Returns an child tree node corresponding to the specified key. If there\n     * is no such a sub-node and the flag \"create\" is true then a new subnode is\n     * created.\n     */\n    get : function(key, create) {\n        var that = this;\n        var result = this._children[key];\n        if (!result) {\n            var path = key.split('/');\n            result = this._getByPath(path, 0, create);\n        }\n        return result;\n    },\n\n    /**\n     * Returns all child nodes corresponding to the specified keys or all\n     * children if keys are not defined.\n     */\n    getAll : function() {\n        var that = this;\n        var keys = _.toArray(arguments);\n        var results = [];\n        that._forEach(keys, function(child) {\n            results.push(child);\n        });\n        return results;\n    },\n\n    /**\n     * Returns keys of all children of this tree node. This method keeps the\n     * internal order of elements.\n     */\n    getAllKeys : function() {\n        var that = this;\n        return _.keys(that._children);\n    },\n\n    /**\n     * Returns true if this node is a parent of the specified tree node.\n     */\n    isParentOf : function(node, includeThis) {\n        var n = includeThis !== false ? node : node.getParent();\n        var result = false;\n        while (n) {\n            result = (n === this);\n            if (result)\n                break;\n            n = n.getParent();\n        }\n        return result;\n    },\n\n    /**\n     * Finds and returns a child in this node or in a sub-nodes corresponding to\n     * the specified key.\n     */\n    find : function(key) {\n        var that = this;\n        var thisKey = that.getKey();\n        var result;\n        if (key == thisKey) {\n            result = that;\n        } else {\n            that._forEach([], function(child) {\n                result = child.find(key);\n                return !result;\n            });\n        }\n        return result;\n    },\n\n    /**\n     * Removes an item corresponding to the specified key from this group.\n     */\n    remove : function(key) {\n        var that = this;\n        var child = that._children[key];\n        if (child) {\n            child._notify('remove', {});\n            delete that._children[key];\n        }\n        return child;\n    },\n\n    /**\n     * Calls the specified callback for all nodes.\n     */\n    visit : function(visitor) {\n        var that = this;\n        var visit = true;\n        if (_.isFunction(visitor.before)) {\n            visit = visitor.before(that) !== false;\n        }\n        if (visit) {\n            _.each(that._children, function(child) {\n                child.visit(visitor);\n            });\n        }\n        if (_.isFunction(visitor.after)) {\n            visitor.after(that);\n        }\n    },\n\n    /**\n     * Returns a node corresponding to the specified path.\n     * \n     * @param path\n     *                an array of path segments to the required node\n     * @param idx\n     *                position of the current key in the path\n     * @param create\n     *                if this flag is <code>true</code> and there is no node\n     *                corresponding to the specified path then a new node is\n     *                created\n     */\n    _getByPath : function(path, idx, create) {\n        var key = idx >= 0 && idx < path.length ? path[idx] : null;\n        if (!key)\n            return;\n        var result = this._children[key];\n\n        if (!result && create) {\n            result = this.add(key);\n        }\n        if (!result)\n            return result;\n        return idx < path.length - 1 ? //\n        result._getByPath(path, idx + 1, create) : //\n        result;\n    },\n\n    /**\n     * Calls the specified callback for all slots corresponding to the given\n     * keys. If no keys are specified then this method iterates over all slots.\n     */\n    _forEach : function(keys, callback) {\n        var index = 0;\n        function visit(child) {\n            var stop = false;\n            if (child) {\n                var cont = callback.call(that, child, index);\n                stop = (cont === false);\n            }\n            index++;\n            return stop;\n        }\n        var that = this;\n        if (_.isFunction(keys)) {\n            callback = keys;\n            keys = [];\n        }\n        if (!keys || !keys.length) {\n            _.find(that._children, visit);\n        } else {\n            _.find(keys, function(key) {\n                var child = that._children[key];\n                return visit(child);\n            });\n        }\n    },\n\n    /**\n     * Notifies all listeners of this node and all parent nodes about the\n     * specified event.\n     */\n    _notify : function(eventKey, event) {\n        var node = this;\n        event.node = node;\n        while (node) {\n            node.triggerMethod(eventKey, event);\n            if (event.stopPropagation)\n                break;\n            node = node.getParent();\n        }\n    },\n\n    /**\n     * Creates and returns a new tree node corresponding to the specified key\n     */\n    _newChild : function(key) {\n        var Type = this.getClass();\n        return new Type(_.extend({}, this.options, {\n            key : key\n        }));\n    },\n});\n\n/* -------------------------------------------------------------- */\n\n/**\n * This mixin is used to add status management for Mosaic.TreeNode instances.\n */\nvar TreeNodeStatusMixin = {\n\n    /** Defaults status value */\n    _status : 'inactive',\n\n    /**\n     * Returns a \"status\" of this tree node. Status value reflects the state of\n     * this node which depends on the usage of this tree.\n     */\n    getStatus : function() {\n        return this._status || '';\n    },\n\n    /**\n     * Returns a \"status\" of this tree node. Status value reflects the state of\n     * this node which depends on the usage of this tree.\n     */\n    setStatus : function(status, options) {\n        var prevStatus = this._status;\n        var update = prevStatus != status || options && options.force;\n        if (update) {\n            this._status = status;\n            this._notify('status', _.extend({}, options, {\n                prevStatus : prevStatus\n            }));\n        }\n        return update;\n    },\n\n    /**\n     * Sets an exclusive mode for this node. It means that just one sub-node can\n     * be active at once. Already active sub-node is automatically deactivated\n     * if an another child is activated.\n     */\n    setExclusive : function(exclusive) {\n        this.options.exclusive = !!exclusive;\n    },\n\n    /**\n     * Returns <code>true</code> if just one sub-node can be active at once.\n     */\n    isExclusive : function() {\n        return this.options.mode == 'exclusive' || //\n        this.options.exclusive !== false;\n    },\n\n    /** Returns true if this node is active */\n    isActive : function() {\n        return this._status == 'active';\n    },\n\n    /**\n     * Activates this node.\n     */\n    activate : function(options) {\n        return this.setStatus('active', options);\n    },\n\n    /**\n     * Deactivates this node.\n     */\n    deactivate : function(options) {\n        return this.setStatus('inactive', options);\n    },\n\n    /** Activates inactive nodes and deactivates active ones. */\n    toggle : function(options) {\n        if (this.isActive()) {\n            return this.deactivate(options);\n        } else {\n            return this.activate(options);\n        }\n    },\n\n    /** Returns a list of all active direct children of this node. */\n    getActive : function() {\n        var list = this.getAll();\n        return _.map(list, function(n) {\n            return n.isActive();\n        });\n    },\n\n    /** Returns a first active direct child. */\n    getFirstActive : function() {\n        var list = this.getAll();\n        return _.find(list, function(n) {\n            return n.isActive();\n        });\n    },\n\n    /**\n     * Returns statistics about all states of child items. The returned object\n     * maps status to lists of child node keys.\n     */\n    getStats : function() {\n        var that = this;\n        var result = {\n            all : []\n        };\n        that._forEach([], function(child) {\n            var key = child.getKey();\n            result.all.push(key);\n            var status = child.getStatus();\n            var array = result[status] = result[status] || [];\n            array.push(key);\n        });\n        return result;\n    },\n\n    /**\n     * This method is notified when the status of a child node is changed. It\n     * checks this tree node is in the exclusive mode and in this case\n     * deactivates all other nodes.\n     */\n    onStatus : (function() {\n        // Returns a new event with a flag that this is an\n        // \"internal\"\n        // event fired by this method; This flag is used to\n        // avoid\n        // infinite event loops.\n        function newEvent() {\n            return {\n                internal : true\n            };\n        }\n        // Activates all node before and deactivates after\n        // already\n        // active subnode\n        function activateBefore(child, stage) {\n            if (stage == 'before') {\n                child.activate(newEvent());\n            } else if (stage == 'after') {\n                child.deactivate(newEvent());\n            }\n        }\n        // Deactivates all nodes before and after already active subnode\n        function activateAfter(child, stage) {\n            function addChildren(node, obj) {\n                _.each(obj, function(value, key) {\n                    if (key == '_') {\n                        node.setOptions(value);\n                        return;\n                    }\n                    var child = node.get(key, true);\n                    child.value = value;\n                    if (_.isObject(value)) {\n                        addChildren(child, value);\n                    }\n                });\n            }\n\n            if (stage == 'before') {\n                child.deactivate(newEvent());\n            } else if (stage == 'after') {\n                child.activate(newEvent());\n            }\n        }\n        // Deactivate all subnodes but the already active one\n        function exclusive(child, stage) {\n            if (stage == 'before' || stage == 'after') {\n                child.deactivate(newEvent());\n            }\n        }\n        // Activates/deactivates child nodes for this tree node\n        function handleChildren(that, evt) {\n            var checkMode;\n            if (that.options.mode == 'activateBefore') {\n                checkMode = activateBefore;\n            } else if (that.options.mode == 'activateAfter') {\n                checkMode = activateAfter;\n            } else if (that.isExclusive()) {\n                checkMode = exclusive;\n            }\n            if (checkMode) {\n                var stage = 'before';\n                var f = function(child) {\n                    if (stage == 'before' && //\n                    child.isParentOf(evt.node, true)) {\n                        stage = 'in';\n                    }\n                    checkMode(child, stage);\n                    if (stage == 'in') {\n                        stage = 'after';\n                    }\n                };\n                that._forEach([], f);\n            }\n        }\n        return function(evt) {\n            var that = this;\n            if (evt.node != that) {\n                // One of sub-nodes was activated\n                if (evt.node.isActive() && !evt.internal) {\n                    handleChildren(that, evt);\n                    that.activate();\n                }\n            } else {\n                // Deactivating of this node\n                if (!that.isActive() && that.options.deactivateAll) {\n                    that.visit({\n                        after : function(child) {\n                            child.deactivate(newEvent());\n                        }\n                    });\n                }\n            }\n        };\n    })(),\n};\n\nvar ActivationTree = TreeNode.extend(TreeNodeStatusMixin, {\n    initialize : function(options) {\n        var proto = TreeNode.prototype;\n        proto.initialize.call(this, options);\n        this.setOptions({\n            deactivateAll : true\n        });\n    }\n});\n\nmodule.exports = ActivationTree;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ActivationTree.js\n ** module id = 14\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\nvar React = require('react');\n\n/**\n * This is an \"infinite scroll\" widget allowing to load elements by their\n * position.\n */\nmodule.exports = React.createClass({\n\n    /** The main rendering method. */\n    render : function() {\n        var items = this.state.items || [];\n        var size = this._getSize();\n        var h = this._getItemHeight();\n        var blockPos = (this.state.index || 0) * h;\n        var fullHeight = size * h;\n\n        return React.DOM.div({\n            id : this.props.id,\n            className : this.props.className,\n            style : this.props.style,\n            onScroll : this._onScroll\n        }, React.DOM.div({\n            ref : 'wrapper',\n            style : {\n                height : fullHeight + 'px',\n                position : 'relative',\n            // overflow : 'hidden'\n            }\n        }, React.DOM.div({\n            ref : 'block',\n            style : {\n                top : blockPos + 'px',\n                position : 'absolute',\n                left : '0px',\n                right : '0px',\n                bottom : 'auto'\n            }\n        }, items)));\n    },\n\n    // -------------------------------------------------------------------\n    // React lifecycle methods\n    /**\n     * This method creates \"debounced\" versions of some methods to avoid to\n     * frequent calls\n     */\n    componentWillMount : function(nextProps) {\n        this._adjustPosition = _.debounce(this._adjustPosition, 5);\n        this._setScrollPos = _.debounce(_.bind(this._setScrollPos, this), 30);\n    },\n    /** Initializes the scroll and set it in an initial position. */\n    componentDidMount : function() {\n        this._resetScrollPos(this.props);\n    },\n    /** Updates the position of the scroller. */\n    componentWillReceiveProps : function(nextProps) {\n        this._resetScrollPos(nextProps);\n    },\n    /**\n     * This method is called after the component is rendered and it adjusts\n     * position of the item block.\n     */\n    componentDidUpdate : function() {\n        this._adjustPosition();\n    },\n    /** Creates and returns the inital state object for this component. */\n    getInitialState : function() {\n        return this._newState({\n            index : 0,\n            length : 0,\n            items : [],\n            scrollPos : 0\n        });\n    },\n\n    // -------------------------------------------------------------------\n    // Internal (private) methods\n\n    /**\n     * This is an internal method creating and returning a new state.\n     */\n    _newState : function(options) {\n        return _.extend({}, this.state, options);\n    },\n    /**\n     * This method returns the size of a \"page\" - size of block of items loaded\n     * at once. By default this method returns the \"this.props.pageSize\" value.\n     */\n    _getPageSize : function() {\n        return this.props.pageSize || 4;\n    },\n    /**\n     * Returns the total number of items to visualize in this scroll.\n     */\n    _getSize : function() {\n        return this.props.length || 0;\n    },\n    /**\n     * Returns an average size of each individual item in the list. This value\n     * is used to calculate the total size of the scroll. By default this method\n     * returns the \"this.props.itemHeight\" value.\n     */\n    _getItemHeight : function() {\n        return this.props.itemHeight || 10;\n    },\n    /**\n     * @param params.index\n     *                start index of the item to load\n     * @param params.length\n     *                number of items to load\n     * @param params.callback\n     *                a callback method accepting the resulting items\n     */\n    _loadItems : function(params) {\n        this.props.loadItems(params);\n    },\n    /**\n     * Sets the scroll in initial position or in an already existing one if the\n     * initial position is not defined.\n     */\n    _resetScrollPos : function(props) {\n        props = props || this.props;\n        var scrollPos = this.state.scrollPos;\n        var focusedPos = props.focusedIndex;\n        focusedPos = !isNaN(focusedPos) ? focusedPos : -1;\n        var size = this._getSize();\n        if (!isNaN(focusedPos) && focusedPos >= 0 && focusedPos < size) {\n            var h = this._getItemHeight();\n            scrollPos = focusedPos * h;\n        }\n        this._focusedItemIdx = focusedPos;\n        // We need this parameter to refresh because a debounced version\n        // of the _setScrollPos method is used.\n        this._resetPos = true;\n        this._setScrollPos(scrollPos, true);\n    },\n    /**\n     * Adjust the absolute position of the items block to reflect exactly the\n     * position of the scroller. This method is required because real items\n     * sizes could be different from the average size returned by the\n     * \"_getItemHeight\" method.\n     */\n    _adjustPosition : function() {\n        if (!this.isMounted())\n            return;\n        var that = this;\n        var container = that.getDOMNode();\n        var scrollPos = container.scrollTop;\n\n        var h = that._getItemHeight();\n        var pos = scrollPos - that.state.index * h;\n        var height = that.state.items.length * h;\n        var blockNode = that.refs.block.getDOMNode();\n        var blockHeight = blockNode.offsetHeight;\n\n        var blockPos = scrollPos - blockHeight * (pos / height);\n        blockPos = Math.round(blockPos);\n        blockNode.style.top = blockPos + 'px';\n\n        if (!isNaN(that._focusedItemIdx)) {\n            // TODO: move to the item corresponding to this index\n            delete that._focusedItemIdx;\n            setTimeout(function() {\n                container.scrollTop = that.state.scrollPos;\n            }, 30);\n        }\n    },\n    /**\n     * Sets the scroller in the specified position and updates the internal\n     * state if the content should be re-loaded.\n     */\n    _setScrollPos : function(scrollPos, force) {\n        var that = this;\n        if (!that.isMounted())\n            return;\n        var pageSize = that._getPageSize();\n        var h = that._getItemHeight();\n        var container = that.getDOMNode();\n\n        var windowHeight = container.offsetHeight;\n        var delta = windowHeight / 4;\n\n        var startPos = Math.max(scrollPos - delta, 0);\n        var endPos = scrollPos + windowHeight + delta;\n\n        var startItem = Math.floor(startPos / h);\n        var endItem = Math.ceil((endPos + h - 1) / h);\n\n        var startPage = Math.floor(startItem / pageSize);\n        var endPage = Math.ceil((endItem + pageSize - 1) / pageSize);\n\n        var index = startPage * pageSize;\n        var length = (endPage - startPage) * pageSize;\n        var params = {\n            scrollPos : scrollPos,\n            index : index,\n            length : length\n        };\n        if (that._resetPos || force || //\n        params.index != that.state.index || //\n        params.length != that.state.length) {\n            params.callback = function(items) {\n                params.items = items;\n                if (that.isMounted()) {\n                    that.setState(that._newState(params));\n                }\n            };\n            that._loadItems(params);\n            delete that._resetPos;\n        } else {\n            that._adjustPosition();\n        }\n    },\n    /** This handler is called when the scroller changes its position. */\n    _onScroll : function(event) {\n        this._setScrollPos(this.getDOMNode().scrollTop);\n    },\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/InfiniteScroll.js\n ** module id = 15\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\n\n/** Objects of this type are used to keep information about data set entries */\nvar SetEntry = Mosaic.Class.extend(// \nMosaic.Events.prototype, Mosaic.Events, {\n    initialize : function(options) {\n        _.extend(this, options);\n    }\n});\n\n/**\n * This is an abstract set used to manage of key/value pairs and generate\n * notifications about new/updated/removed entries in this set. To perform\n * notifications this class uses the \"_onEnter\", \"_onUpdate\" and \"_onExit\"\n * methods respectively. This class should be extended to add custom behaviour\n * for each type of changes.\n */\nvar AbstractSet = Mosaic.Class.extend(//\nMosaic.Events.prototype, Mosaic.Events, {\n\n    /**\n     * Class constructor.\n     * \n     * @param options.getId\n     *                this optional method is used to retrieve object\n     *                identifiers\n     */\n    initialize : function(options) {\n        this.setOptions(options);\n        if (_.isFunction(this.options.getKey)) {\n            this.getKey = this.options.getKey;\n        }\n        this._index = {};\n    },\n\n    /**\n     * Sets a new array of objects and calls onEnter, onUpdate and onExit\n     * methods for each entry; each index contains keys and the corresponding\n     * index entries with \"key\", \"obj\" and \"idx\" fields (where \"key\" is the key\n     * of the object; \"obj\" the object itself and \"idx\" the index of this object\n     * in the list). This method returns reference to this instance to allow\n     * methods call chaining.\n     */\n    _setObjects : function(objects) {\n        var that = this;\n        var array = _.toArray(objects);\n        var newIndex = {};\n        var event = {\n            enter : {},\n            update : {},\n            exit : {}\n        };\n        _.each(array, function(d, i) {\n            var key = that.getKey(d);\n            var entry;\n            if (_.has(that._index, key)) {\n                entry = that._onUpdate(that._index[key]) || entry;\n                delete that._index[key];\n                event.update[entry.key] = entry;\n            } else {\n                entry = that._newSetEntry({\n                    key : key,\n                    obj : d,\n                    idx : i\n                });\n                entry = that._onEnter(entry) || entry;\n                event.enter[entry.key] = entry;\n            }\n            newIndex[key] = entry;\n        });\n        _.each(that._index, function(entry) {\n            event.exit[entry.key] = that._onExit(entry) || entry;\n        });\n        that._index = newIndex;\n        return event;\n    },\n\n    /** Creates and returns a SetEntry instance. */\n    _newSetEntry : function(options) {\n        return new SetEntry(options);\n    },\n\n    /**\n     * This method returns index entries containing the data, the corresponding\n     * key and position of the data object in the array.\n     */\n    _getIndexEntries : function(key) {\n        if (key) {\n            if (_.isArray(key)) {\n                return _.map(key, function(k) {\n                    return this._index[k];\n                }, this);\n            } else {\n                return this._index[key];\n            }\n        } else {\n            return _.values(this._index);\n        }\n    },\n\n    /**\n     * This method returns an index entry corresponding to the specified key.\n     */\n    _getIndexEntry : function(key) {\n        return this._index[key];\n    },\n\n    /**\n     * This method returns a key for the specified object. By default this\n     * method returns the object itself. To change this behaviour this method\n     * could be overloaded in subclasses or a \"getKey\" function can be set in\n     * the constructor parameters.\n     */\n    getKey : function(d) {\n        return d;\n    },\n\n    /**\n     * This method returns a list of all object keys.\n     */\n    getKeys : function() {\n        return _.keys(this._index);\n    },\n\n    /**\n     * This method is called when a new object is added to the index.\n     * \n     * @param entry\n     *                an index entry object containing the index, its position\n     *                and the corresponding key\n     */\n    _onEnter : function(entry) {\n        entry.emit('enter');\n        return entry;\n    },\n\n    /**\n     * This method is called when an object is removed from the index.\n     * \n     * @param entry\n     *                an index entry object containing the index, its position\n     *                and the corresponding key\n     */\n    _onExit : function(entry) {\n        entry.emit('exit');\n        return entry;\n    },\n\n    /**\n     * This method is called to notify about updated (already existing in index)\n     * objects.\n     * \n     * @param entry\n     *                an index entry object containing the index, its position\n     *                and the corresponding key\n     */\n    _onUpdate : function(entry) {\n        entry.emit('update');\n        return entry;\n    },\n\n    /** Gets the index of an entry with the specified key. */\n    getIndex : function(key) {\n        var entry = key ? this._index[key] : null;\n        return entry ? entry.idx : -1;\n    },\n\n    /**\n     * Returns <code>true</code> if this set contains the specified key.\n     */\n    hasKey : function(key) {\n        return _.has(this._index, key);\n    }\n});\nAbstractSet.SetEntry = SetEntry;\n\nmodule.exports = AbstractSet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/AbstractSet.js\n ** module id = 16\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar Mosaic = require('mosaic-commons');\nvar Class = Mosaic.Class;\n\n/**\n * An adapter manager used to register/retrieve objects corresponding to the\n * types of adaptable object and the types of the target object. This object is\n * used by views to get view adapters.\n */\nvar AdapterManager = Class.extend({\n    TYPE_KEY_DELIM : '/',\n\n    /** Initializes this object */\n    initialize : function() {\n        this._adapters = {};\n        this._cache = {};\n    },\n\n    /**\n     * Returns a key used to find adapters of one type to another.\n     * \n     * @param from\n     *                the type of the adaptable object\n     * @param to\n     *                type of the target object\n     */\n    _getKey : function(from, to) {\n        var fromType = this.getTypeKey(from);\n        var toType = this.getTypeKey(to);\n        return fromType + '::' + toType;\n    },\n\n    /**\n     * Registers a new adapter from one type to another.\n     * \n     * @param from\n     *                the type of the adaptable object\n     * @param to\n     *                type of the target object\n     * @param adapter\n     *                the adapter type\n     */\n    registerAdapter : function(from, to, adapter) {\n        var key = this._getKey(from, to);\n        this._adapters[key] = adapter;\n        this._cache = {};\n    },\n\n    /** Returns an adapter of one object type to another type. */\n    getAdapter : function(from, to) {\n        var that = this;\n        var cacheKey = that._getKey(from, to);\n        var result = that._cache[cacheKey];\n        if (!result && !_.has(that._cache, cacheKey)) {\n            _.find(that._expandId(from), function(f) {\n                _.find(that._expandId(to), function(t) {\n                    var key = that._getKey(f, t);\n                    result = that._adapters[key];\n                    return !!result;\n                });\n                return !!result;\n            });\n            that._cache[cacheKey] = result;\n        }\n        return result;\n    },\n\n    /**\n     * Creates and returns a new adapter from one type to another. If the\n     * registered adapter is a function then it is used as constructor to create\n     * a new object.\n     */\n    newAdapterInstance : function(from, to, options) {\n        var AdapterType = this.getAdapter(from, to);\n        var result = null;\n        if (_.isFunction(AdapterType)) {\n            options = options || {};\n            if (this._checkValidity(AdapterType, options)) {\n                if (_.isFunction(AdapterType.initialize)) {\n                    AdapterType.initialize(options);\n                }\n                result = new AdapterType(options);\n                if (!this._checkValidity(result, options)) {\n                    result = null;\n                }\n            }\n        } else {\n            result = AdapterType;\n        }\n        return result;\n    },\n\n    /** Removes an adapter from one type to another. */\n    removeAdapter : function(from, to) {\n        var key = this._getKey(from, to);\n        var result = this._adapters[key];\n        delete this._adapters[key];\n        delete this._cache[key];\n        return result;\n    },\n\n    /**\n     * Checks if option values are valid using validation methods on the\n     * specified object\n     */\n    _checkValidity : function(obj, options) {\n        if (!_.isFunction(obj.isValid))\n            return true;\n        var result = obj.isValid(options);\n        return result;\n    },\n\n    /**\n     * Expand the specified key to an array of keys taking into account\n     * inheritance defined in the key.\n     */\n    _expandId : function(key) {\n        if (!key)\n            return [];\n        var result = [];\n        var handled = false;\n        while (_.isFunction(key.getParent)) {\n            handled = true;\n            key = key.getParent();\n            if (key) {\n                result.push(key);\n            } else {\n                break;\n            }\n        }\n        if (!handled && _.isString(key)) {\n            key = this._normalizeTypeKey(key);\n            var delim = this.TYPE_KEY_DELIM;\n            var array = key.split(delim);\n            while (array.length) {\n                var k = array.join(delim);\n                result.push(k);\n                array.pop();\n            }\n            result.push('');\n        }\n        return result;\n    },\n\n    /** Returns the type of the specified resource. */\n    getTypeKey : function(obj) {\n        var type;\n        if (obj) {\n            if (_.isString(obj)) {\n                type = obj;\n            } else {\n                var cls = null;\n                if (_.isFunction(obj)) {\n                    cls = obj;\n                } else if (_.isFunction(obj.getClass)) {\n                    cls = obj.getClass();\n                }\n                var proto;\n                if (_.isFunction(cls)) {\n                    proto = cls.prototype;\n                } else {\n                    proto = obj.prototype;\n                }\n                type = proto.__type;\n                if (!type) {\n                    type = obj.type = obj.type || _.uniqueId('type-');\n                }\n            }\n        }\n        return this._normalizeTypeKey(type);\n    },\n\n    /**\n     * Returns a normalized key used to put values in the internal index and in\n     * the cache.\n     */\n    _normalizeTypeKey : function(key) {\n        if (!_.isString(key))\n            return key;\n        if (key === '')\n            return '';\n        var delim = this.TYPE_KEY_DELIM;\n        if (key.indexOf(delim) === 0) {\n            key = delim.substring(delim.length);\n        }\n        if (key.lastIndexOf(delim) == key.length - delim.length) {\n            key = key.substring(0, key.length - delim.length);\n        }\n        return key;\n    }\n});\n\nmodule.exports = AdapterManager;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/AdapterManager.js\n ** module id = 17\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar DataSet = require('./DataSet');\n\n/**\n * This class is used to merge multiple datasets in one based on common data\n * keys.\n */\nvar CompositeDataSet = DataSet.extend({\n\n    /**\n     * Constructor of this class.\n     * \n     * @param options.getKey\n     *                an function returning the key in the merged results\n     * @param options.dataSets\n     *                a list of data sets used as a source of data objects\n     * @param options.merge\n     *                a function accepting an array of data entries from all\n     *                data sets corresponding to the same key\n     */\n    initialize : function(options) {\n        DataSet.prototype.initialize.apply(this, arguments);\n        this._filterDataSets = _.bind(this._filterDataSets, this);\n        this.setFilter(this.options.filterData || this.options.filter);\n        this.open();\n    },\n\n    /**\n     * Opens this data set - registeres data set listeners and launches the\n     * initial data merge.\n     */\n    open : function() {\n        if (!DataSet.prototype.open.apply(this, arguments))\n            return false;\n        _.each(this.options.dataSets, function(dataSet) {\n            dataSet.on('update', this._filterDataSets);\n        }, this);\n        this._filterDataSets();\n        return true;\n    },\n\n    /** Closes this dataset. It removes all registered listeners. */\n    close : function() {\n        if (!DataSet.prototype.close.apply(this, arguments))\n            return false;\n        _.each(this.options.dataSets, function(dataSet) {\n            dataSet.off('update', this._filterDataSets);\n        }, this);\n        DataSet.prototype.setData.call(this, []);\n        return true;\n    },\n\n    /** Sets a new filter and updates this data set. */\n    setFilter : function(filter) {\n        this._filter = filter;\n        this._filterDataSets();\n        return this;\n    },\n\n    /**\n     * This method all data sets. It calls the \"_filterData\" method for all\n     * objects corresponding to the same key from all datasets.\n     */\n    _filterDataSets : function() {\n        var keys = {};\n        var dataSets = this.options.dataSets;\n        _.each(dataSets, function(dataSet) {\n            _.each(dataSet.getKeys(), function(key) {\n                keys[key] = true;\n            });\n        }, this);\n        var data = [];\n        _.each(_.keys(keys), function(key) {\n            var array = _.map(dataSets, function(dataSet) {\n                var entry = dataSet.getDataEntries(key);\n                return entry;\n            });\n            var obj = this._filterData(key, array);\n            if (obj) {\n                data.push(obj);\n            }\n        }, this);\n        DataSet.prototype.setData.call(this, data);\n    },\n\n    /**\n     * Filters/merges individual index entries corresponding to the same key.\n     * \n     * @param array\n     *                an array of index entries from all datasets corresponding\n     *                to the same key; each entry contains the \"obj\", \"idx\" and\n     *                \"key\" fields.\n     * @param key\n     *                the key of the data\n     */\n    _filterData : function(key, array) {\n        if (this._filter) {\n            return this._filter(key, array);\n        }\n        var args = [ {} ].concat(array);\n        return _.extend.call(null, args);\n    },\n\n    /**\n     * Overloads the parent \"setData\" method and rises an exception. This class\n     * should not accept direct data changes. It builds its data using parent\n     * data sets.\n     */\n    setData : function() {\n        throw new Error('This method ' + //\n        'should not be called directly. ' + //\n        'This dataset is a combination of parent datasets.');\n    }\n});\n\n/** This datasets choses for each key the first non-empty value. */\nCompositeDataSet.OR = CompositeDataSet.extend({\n    /**\n     * This method returns the first non-empty value from the list of values\n     * corresponding to the specified key.\n     * \n     * @param array\n     *                an array of objects from all datasets corresponding to the\n     *                same key\n     * @param key\n     *                the key of the data\n     */\n    _filterData : function(key, array) {\n        var result = _.find(array, function(val) {\n            return !!val;\n        });\n        return result;\n    },\n});\n\n/** This datasets selects only values existing all datasets. */\nCompositeDataSet.AND = CompositeDataSet.extend({\n    /**\n     * This method returns the first non-empty value from the list of values\n     * corresponding to the specified key.\n     * \n     * @param array\n     *                an array of objects from all datasets corresponding to the\n     *                same key\n     * @param key\n     *                the key of the data\n     */\n    _filterData : function(key, array) {\n        var result = null;\n        return !_.find(array, function(val) {\n            result = val;\n            return !val;\n        }) ? result : null;\n    },\n});\n\nmodule.exports = CompositeDataSet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/CompositeDataSet.js\n ** module id = 18\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\nvar AbstractSet = require('./AbstractSet');\n\n/**\n * Subclasses of this type are used to visualize data set content.\n */\n/**\n * This mixin contains common methods used to visualize data set content.\n */\nvar DataSetView = AbstractSet.extend({\n\n    /**\n     * Constructor of this class. This method expects that the parameters\n     * contain a \"dataSet\" field. These fields \"onEnter\", \"onUpdate\" and\n     * \"onExit\" are used to provide/manage features on the map.\n     * \n     * @param options.dataSet\n     *                a mandatory data set object\n     */\n    initialize : function(options) {\n        AbstractSet.prototype.initialize.apply(this, arguments);\n        this._onDataSetUpdate = _.bind(this._onDataSetUpdate, this);\n        if (!this.options.dataSet) {\n            throw new Error('Data set is not defined.');\n        }\n    },\n\n    /**\n     * Returns a key for the specified object. This method uses the \"getKey\"\n     * method of the underlying data set.\n     */\n    getKey : function(d) {\n        return this.getDataSet().getKey(d);\n    },\n\n    /**\n     * \"Opens\" this view and notify about all already existing nodes.\n     */\n    open : function() {\n        if (this._open)\n            return false;\n        var dataSet = this.getDataSet();\n        dataSet.on('update:end', this._onDataSetUpdate);\n        this._setData(dataSet.getData());\n        this._open = true;\n        return true;\n    },\n\n    /**\n     * Removes this view and unsubscribe from data set notifications.\n     */\n    close : function() {\n        if (!this._open)\n            return false;\n        var dataSet = this.getDataSet();\n        this._setData([]);\n        dataSet.off('update:end', this._onDataSetUpdate);\n        this._open = false;\n        return true;\n    },\n\n    /** Returns the underlying dataset */\n    getDataSet : function() {\n        return this.options.dataSet;\n    },\n\n    /** Rebuild views corresponding to the specified data entries. */\n    _setData : function(data) {\n        var that = this;\n        that.triggerMethod('update:begin');\n        that._setObjects(data);\n        that.triggerMethod('update:end');\n        return this;\n    },\n\n    /**\n     * Handles data set update notifications and render individual views.\n     */\n    _onDataSetUpdate : function(e) {\n        var dataSet = this.getDataSet();\n        var data = dataSet.getData();\n        this._setData(data);\n    },\n\n});\n\nmodule.exports = DataSetView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/DataSetView.js\n ** module id = 19\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\n\n/** This is a simple class used to manage dependencies between entities. */\nvar Dependencies = Mosaic.Class.extend({\n\n    /**\n     * Sets dependencies between modules using a map where keys are module names\n     * and values are lists of dependencies. This method rises an exception if\n     * user tries to set circular dependencies.\n     * \n     * @param dependencies\n     *                a map containing modules with the corresponding arrays of\n     *                dependencies\n     */\n    setDependencies : function(dependencies) {\n        _.each(dependencies, function(deps, module) {\n            this.setDependency(module, deps);\n        }, this);\n    },\n\n    /**\n     * Sets new dependency for the specified module. This method rises an\n     * exception if user tries to set circular dependencies.\n     * \n     * @param key\n     *                the key of the module\n     * @param dependencies\n     *                an array of dependencies for the specified module\n     */\n    setDependency : function(key, dependencies) {\n        var that = this;\n        if (!that._checkDependencies(key, dependencies)) {\n            throw Mosaic.Errors.// \n            newError('Circular dependencies').code(400);\n        }\n        that._setDependencies(key, dependencies);\n    },\n\n    /**\n     * Visits dependencies and notifies the given listener when the visitor\n     * enters and exists from an entry.\n     * \n     * @param key\n     *                the key of an entry to visit\n     */\n    visit : function(key, listener) {\n        if (listener.begin) {\n            listener.begin(key);\n        }\n        var deps = this.getDependencies(key);\n        _.each(deps, function(k) {\n            this.visit(k, listener);\n        }, this);\n        if (listener.end) {\n            listener.end(key);\n        }\n    },\n\n    /**\n     * Asynchronously executes \"begin\" and \"end\" actions in the specified\n     * listener and return a promise with the results of the execution.\n     * \n     * @param key\n     *                the key of the action to launch; if this parameter is an\n     *                array then all keys from this array will be executed\n     * @param listener\n     *                a listener object containing two methods: \"begin\" and\n     *                \"end\"\n     * @param listener.begin\n     *                this method takes one parameter - the key of the current\n     *                action\n     * @param listener.end\n     *                this method takes 3 parameters - 1) key of the action, 2)\n     *                error thrown by previous actions or null 3) result of the\n     *                previous action\n     */\n    callDependencies : function(key, listener) {\n        var that = this;\n        return Mosaic.P.then(function() {\n            if (!_.isArray(key)) {\n                return that._callDependencies({}, key, listener);\n            } else {\n                var promises = {};\n                return Mosaic.P.all(_.map(key, function(k) {\n                    return that._callDependencies(promises, k, listener);\n                }));\n            }\n        });\n    },\n\n    /**\n     * Returns all dependencies of an element with the specified key.\n     */\n    getDependencies : function(key) {\n        return this._getDependencies(key);\n    },\n\n    /**\n     * A list of all dependencies for the specified key in the order of their\n     * resolving.\n     */\n    getAllDependencies : function(key) {\n        var deps = [];\n        this.visit(key, {\n            end : function(k) {\n                if (k !== key) {\n                    deps.push(k);\n                }\n            }\n        });\n        return deps;\n    },\n\n    /**\n     * Executes an action with the specified name and returns a promise with\n     * results.\n     * \n     * @param promises\n     *                index of promises for already executed actions\n     * @param key\n     *                key of the action to execute\n     * @param listener\n     *                a listener object containing two methods \"begin\" and \"end\"\n     * @param listener.begin\n     *                this method takes one parameter - the key of the current\n     *                action\n     * @param listener.end\n     *                this method takes 3 parameters - 1) key of the action, 2)\n     *                error thrown by previous actions or null 3) result of the\n     *                previous action\n     */\n    _callDependencies : function(promises, key, listener) {\n        var that = this;\n        return visit(key);\n        function visit(k) {\n            if (!promises[k]) {\n                promises[k] = Mosaic.P.then(function() {\n                    if (listener.begin)\n                        return listener.begin(k);\n                }).then(function() {\n                    var deps = that.getDependencies(k);\n                    if (!deps || !deps.length)\n                        return;\n                    return Mosaic.P.all(_.map(deps, visit));\n                }).then(function(result) {\n                    if (listener.end)\n                        return listener.end(k, null, result);\n                    else\n                        return result;\n                }, function(err) {\n                    if (listener.end)\n                        return listener.end(k, err, null);\n                    else\n                        throw err;\n                });\n            }\n            return promises[k];\n        }\n    },\n\n    /**\n     * Returns true if the specified dependencies could be set for the given\n     * key.\n     * \n     * @param key\n     *                the key to check\n     * @param dependencies\n     *                a list of dependencies to check\n     */\n    _checkDependencies : function(key, dependencies) {\n        var that = this;\n        var deps = _.isArray(dependencies) ? dependencies : [ dependencies ];\n        return Dependencies.check(key, function(k) {\n            if (k === key) {\n                return deps;\n            } else {\n                return that.getDependencies(k);\n            }\n        });\n    },\n\n    /**\n     * Returns all dependencies of an element with the specified key. This\n     * method could be overloaded in subclasses.\n     */\n    _getDependencies : function(key) {\n        if (!this._dependencies)\n            return [];\n        return this._dependencies[key] || [];\n    },\n\n    /**\n     * Really sets dependencies for a module with the specified key. This method\n     * could be overloaded in subclasses.\n     * \n     * @param key\n     *                for this key a list dependencies should be set\n     * @param deps\n     *                a list of dependencies\n     */\n    _setDependencies : function(key, deps) {\n        if (!this._dependencies) {\n            this._dependencies = [];\n        }\n        this._dependencies[key] = deps;\n    },\n\n});\n\n/**\n * This static method checks that there is no circular dependencies between\n * entities.\n * \n * @param key\n *                the key of the initial dependency\n * @param provider\n *                a function returning an array of all dependencies for the\n *                specified key\n */\nDependencies.check = function(key, provider) {\n    var index = {};\n    function isIndexed(k) {\n        if (index[k])\n            return true;\n        try {\n            index[k] = true;\n            return !!_.find(provider(k), isIndexed);\n        } finally {\n            delete index[k];\n        }\n    }\n    return !isIndexed(key);\n};\n\nmodule.exports = Dependencies;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Dependencies.js\n ** module id = 20\n ** module chunks = 0\n **/","var Mosaic = require('mosaic-commons');\nvar _ = require('underscore');\nvar Dependencies = require('./Dependencies');\n\n/**\n * This class manages intents. Each intent is a deferred object containing the\n * following fields and method: 1) \"promise\"\n */\nvar Intents = Mosaic.Class.extend({\n\n    /**\n     * Initializes and returns an \"api\" for the specified object. It replaces\n     * all methods marked with the \"intentHandler\" flag by an intent calls with\n     * the name of this method. The returned object contains all \"public\"\n     * methods (not started the with \"_\" symbol).\n     */\n    initApi : function(key, obj, methods) {\n        var api = {};\n        var that = this;\n        methods = methods || _.functions(obj);\n        _.each(methods, function(name) {\n            if (name[0] == '_') //\n                return;\n            var action = obj[name];\n            var addToApi = true;\n            if (action.intentHandler) {\n                var intentKey = name;\n                var idx = name.indexOf(':');\n                addToApi = false;\n                if (idx < 0) {\n                    addToApi = true;\n                    intentKey = key + ':' + name;\n                    // Add code to activate the intent; this code is called\n                    // instead of the original method\n                    obj[name] = function(options) {\n                        options = options || {};\n                        var intent = that.newIntent(intentKey, options);\n                        return intent.promise;\n                    };\n                }\n                // Register an intent handler\n                that.addIntentHandler(key, intentKey, function(intent) {\n                    return action.call(obj, intent);\n                });\n            }\n            obj[name] = _.bind(obj[name], obj);\n            if (addToApi) {\n                api[name] = obj[name];\n            }\n        });\n        return api;\n    },\n\n    /**\n     * Creates and propagates a new intent.\n     * \n     * @param intentKey\n     *                key of the intent\n     * @param params\n     *                params of the intent\n     */\n    newIntent : function(intentKey, params) {\n        var intent = new Intents.Intent(intentKey, params);\n        try {\n            var handlers = this._intentHandlers ? // \n            this._intentHandlers[intentKey] : null;\n            _.each(handlers, function(handler, componentKey) {\n                intent._handleComponent(componentKey, handler);\n            });\n        } finally {\n            intent._finalize();\n        }\n        return intent;\n    },\n\n    /**\n     * Add intent handlers.\n     * \n     * @param componentKey\n     *                an optional key of a component registering handlers; this\n     *                key could be used to manage dependencies to wait intent\n     *                results\n     * @param handlers\n     *                a map containing intent keys and the corresponding\n     *                handlers\n     */\n    addIntentHandlers : function(componentKey, handlers) {\n        var args = _.toArray(arguments);\n        handlers = args.pop();\n        componentKey = this._checkComponentKey(args.pop());\n        _.each(handlers, function(handler, intentKey) {\n            this.addIntentHandler(componentKey, intentKey, handler);\n        }, this);\n    },\n\n    /**\n     * Adds a new handler for the specified type of intents.\n     * \n     * @param componentKey\n     *                an optional key of a component registering handlers; this\n     *                key could be used to manage dependencies to wait intent\n     *                results\n     * @param intentKey\n     *                intent key\n     * @param handler\n     *                handler function to add\n     */\n    addIntentHandler : function(componentKey, intentKey, handler) {\n        var args = _.toArray(arguments);\n        handler = args.pop();\n        intentKey = args.pop();\n        componentKey = this._checkComponentKey(args.pop());\n        if (!this._intentHandlers) {\n            this._intentHandlers = {};\n        }\n        var handlers = this._intentHandlers[intentKey] = //\n        this._intentHandlers[intentKey] || {};\n        handlers[componentKey] = handler;\n    },\n\n    /**\n     * Removes all intent handlers specified in the given map.\n     * \n     * @param componentKey\n     *                an optional key of a component registered handlers\n     * @param handlers\n     *                a map containing intent keys and the corresponding\n     *                handlers\n     */\n    removeIntentHandlers : function(componentKey, handlers) {\n        if (!handlers) {\n            handlers = componentKey;\n            componentKey = null;\n        }\n        _.each(handlers, function(handler, intentKey) {\n            this.removeIntentHandler(componentKey, intentKey, handler);\n        }, this);\n    },\n\n    /**\n     * Removes an intent handler for the specified type of intents.\n     * \n     * @param componentKey\n     *                an optional key of a component registered handlers\n     * @param intentKey\n     *                intent key\n     * @param handler\n     *                handler function to remove\n     */\n    removeIntentHandler : function(componentKey, intentKey, handler) {\n        if (!this._intentHandlers)\n            return;\n        if (!handler) {\n            handlers = intentKey;\n            intentKey = componentKey;\n            componentKey = null;\n        }\n        var handlers = this._intentHandlers[intentKey];\n        var toRemove = [];\n        if (componentKey) {\n            _.each(handlers, function(h, k) {\n                if (handler === h) {\n                    toRemove.push(k);\n                }\n            });\n        } else {\n            toRemove.push(componentKey);\n        }\n        _.each(toRemove, function(k) {\n            delete handlers[k];\n        });\n    },\n\n    /**\n     * Checks the specified component key and returns a random unique one if the\n     * specified key is not defined.\n     */\n    _checkComponentKey : function(componentKey) {\n        return componentKey || _.uniqueId('$$cmp-');\n    },\n\n});\n\n/**\n * Intents implementation. It has the following all fields of a deferred object\n * (see Promises) and some specific fields like \"intentKey\":\n * <ul>\n * <li>\"promise\" - a promise field</li>\n * <li>\"resolve\" - <code>function(result){...}</code> - a function resolving\n * this intent </li>\n * <li>\"reject\" - <code>function(err){...}</code> - a function rejecting this\n * intent </li>\n * <li>\"intentKey\" - type (key) of this intent</li>\n * <li>\"waitFor\" - <code>function(dependencies){...}</code> - a function\n * allowing to wait while other components finish their handling of intent\n * results\n * </ul>\n */\nIntents.Intent = Mosaic.Class.extend({\n\n    /** Initializes parameters of this intent. */\n    initialize : function(intentKey, params) {\n        this._deferred = Mosaic.P.defer();\n        this._processed = Mosaic.P.defer();\n        this.intentKey = intentKey;\n        this.params = params;\n        this.promise = this._deferred.promise;\n        this.processed = this._processed.promise;\n        this._handlerPromises = {};\n        this._dependencies = new Dependencies();\n        this._handled = false;\n    },\n\n    /** Resolves this intent with the specified value. */\n    resolve : function(result) {\n        this._handled = true;\n        this._deferred.resolve(result);\n        return this._deferred.promise;\n    },\n\n    /** Rejects this intent with the specified error. */\n    reject : function(err) {\n        this._handled = true;\n        this._deferred.reject(err);\n        return this._deferred.promise;\n    },\n\n    /** Executes \"then\" function of the promise. */\n    then : function(resolved, rejected) {\n        return this._deferred.promise.then(resolved, rejected);\n    },\n\n    /**\n     * This method allows to wait for the results returned by the specified\n     * components before executing handler actions.\n     * \n     * @param dependencies\n     *                an array of component keys to wait\n     */\n    waitFor : function(dependencies) {\n        if (!this._componentKey) {\n            throw new Error('Component handler is not defined. ' + //\n            'This method could be called ' + //\n            'only from an intent handler.');\n        }\n        var that = this;\n        _.each(dependencies, function(dependencyKey) {\n            that._dependencies.setDependency(dependencyKey);\n        });\n        return that._deferred.promise.then(function(result) {\n            return Mosaic.P.all(_.map(dependencies, function(key) {\n                var promise = that._handlerPromises[key];\n                if (!promise) {\n                    promise = Mosaic.P();\n                }\n                return promise;\n            })).then(function() {\n                return result;\n            });\n        });\n    },\n\n    /**\n     * Executes a handler of this intent.\n     * \n     * @param componentKey\n     *                key of the component handler\n     * @param handler\n     *                handler function\n     */\n    _handleComponent : function(componentKey, handler) {\n        var that = this;\n        var promise;\n        try {\n            that._componentKey = componentKey;\n            promise = Mosaic.P.resolve(handler(that));\n        } catch (err) {\n            promise = Mosaic.P.reject(err);\n        } finally {\n            this._handlerPromises[componentKey] = promise;\n            delete that._componentKey;\n        }\n    },\n\n    /**\n     * Finalizes this intent and resolves/reject it. If there is no handlers\n     * resolved nor rejected this intent then this method resolves the promise\n     * of this intent with an exception.\n     */\n    _finalize : function() {\n        var that = this;\n        if (!that._handled) {\n            that.reject(new Error('An intent was not handled.'));\n        }\n        var finalize = function() {\n            var componentKeys = _.keys(that._handlerPromises);\n            return that._dependencies.callDependencies(componentKeys, {\n                end : function(key, err, res) {\n                    if (err) {\n                        throw err;\n                    }\n                    return that._handlerPromises[key];\n                }\n            }).then(function(result) {\n                that._processed.resolve(result);\n                return result;\n            }, function(err) {\n                that._processed.reject(err);\n                throw err;\n            });\n        };\n        return that._deferred.promise.then(finalize, finalize);\n    }\n});\n\n/**\n * A simple utility method marking the specified method with the \"intentHandler\"\n * flag.\n */\nIntents.handler = function(m) {\n    m.intentHandler = true;\n    return m;\n};\n\nmodule.exports = Intents;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Intents.js\n ** module id = 21\n ** module chunks = 0\n **/","var L = require('leaflet');\r\nvar DataSetView = require('./DataSetView');\r\n\r\n/**\r\n * A Leaflet layer providing automatic rendering of data from a dataset. This\r\n * class uses the \"onEnter\", \"onUpdate\" and \"onExit\" callbacks to generate\r\n * visible features on the map. Use the \"LeafletFeatureBuilder\" class to\r\n * simplify creation of leaflet features in these callbacks.\r\n */\r\nvar LeafletDataSetView = DataSetView.extend({\r\n\r\n    initialize : function(options) {\r\n        DataSetView.prototype.initialize.apply(this, arguments);\r\n        // this._onZoomEnd = _.debounce(_.bind(this._onZoomEnd, this), 200);\r\n        this._onZoomEnd = _.bind(this._onZoomEnd, this);\r\n    },\r\n\r\n    /**\r\n     * This method is used by Leaflet when this layer is inserted in the map.\r\n     */\r\n    onAdd : function(map) {\r\n        this._map = map;\r\n        this._map.on('zoomend', this._onZoomEnd);\r\n        this._layer = new L.featureGroup();\r\n        this._map.addLayer(this._layer);\r\n        this.open();\r\n        this._onZoomEnd();\r\n    },\r\n\r\n    /**\r\n     * This method is called by Leaflet to remove this layer from the map.\r\n     */\r\n    onRemove : function(map) {\r\n        this.close();\r\n        this._map.removeLayer(this._layer);\r\n        this._map.off('zoomend', this._onZoomEnd);\r\n        delete this._map;\r\n        delete this._layer;\r\n    },\r\n\r\n    /**\r\n     * Creates a new view and attaches it to the specified index entry.\r\n     */\r\n    _onEnter : function(entry) {\r\n        entry.layer = this._newLeafletLayer(entry);\r\n        if (entry.layer) {\r\n            this._layer.addLayer(entry.layer);\r\n        }\r\n        entry.emit('enter');\r\n        return entry;\r\n    },\r\n\r\n    /**\r\n     * Destroys a view in the specified index entry. This method should be\r\n     * overloaded in subclasses.\r\n     */\r\n    _onExit : function(entry) {\r\n        if (entry.layer) {\r\n            this._layer.removeLayer(entry.layer);\r\n        }\r\n        entry.emit('exit');\r\n        return entry;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns a new leaflet layer for the specified entry. This\r\n     * method should be overloaded in subclasses to create real map entities.\r\n     */\r\n    _newLeafletLayer : function(entry) {\r\n    },\r\n\r\n    /** This method is called when the map changes its zoom level. */\r\n    _onZoomEnd : function() {\r\n        var that = this;\r\n        var zoom = that._map.getZoom();\r\n        _.each(that._index, function(entry) {\r\n            entry.emit('zoomend', {\r\n                entry : entry,\r\n                zoom : zoom\r\n            });\r\n        });\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LeafletDataSetView;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LeafletDataSetView.js\n ** module id = 22\n ** module chunks = 0\n **/","var DataSetView = require('./DataSetView');\r\n\r\n/**\r\n * This class manages entries of sub-sets of a data set. It does not add/remove\r\n * features on the map, it just changes their representation.\r\n */\r\nvar LeafletDataSubsetView = DataSetView.extend({\r\n\r\n    /**\r\n     * Creates a new view and attaches it to the specified index entry.\r\n     */\r\n    _onEnter : function(entry) {\r\n        var parentView = this.options.parent;\r\n        if (parentView) {\r\n            var parentEntry = parentView._getIndexEntry(entry.key);\r\n            // Copies all fields from a view found in the parent\r\n            _.extend(entry, parentEntry);\r\n        }\r\n        entry.emit('enter');\r\n        return entry;\r\n    },\r\n\r\n    /**\r\n     * This method is used by Leaflet when this layer is inserted in the map.\r\n     */\r\n    onAdd : function(map) {\r\n        this.open();\r\n    },\r\n\r\n    /** This method is called by Leaflet to remove this layer from the map. */\r\n    onRemove : function(map) {\r\n        this.close();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LeafletDataSubsetView;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/LeafletDataSubsetView.js\n ** module id = 23\n ** module chunks = 0\n **/","var _ = require('underscore');\r\n\r\n/**\r\n * This is a common mixin used by React classes to add automatic binding for\r\n * DataSets.\r\n */\r\nmodule.exports = {\r\n\r\n    getDataSet : function() {\r\n        return this.props.dataSet;\r\n    },\r\n\r\n    componentWillMount : function() {\r\n        var dataSet = this.getDataSet();\r\n        dataSet.on('update:end', this._onUpdate);\r\n    },\r\n\r\n    componentWillUnmount : function() {\r\n        var dataSet = this.getDataSet();\r\n        dataSet.off('update:end', this._onUpdate);\r\n    },\r\n\r\n    _onUpdate : function() {\r\n        var that = this;\r\n        that.setState(that._newState());\r\n    },\r\n\r\n    getInitialState : function() {\r\n        return this._newState();\r\n    },\r\n\r\n    _newState : function() {\r\n        return {};\r\n    },\r\n\r\n    renderChildren : function() {\r\n        var dataSet = this.getDataSet();\r\n        var list = _.map(dataSet._getIndexEntries(), function(entry) {\r\n            return this.renderChild(entry);\r\n        }, this);\r\n        return list;\r\n    },\r\n\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ReactDataSetMixin.js\n ** module id = 24\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar Mosaic = require('mosaic-commons');\nvar AdapterManager = require('./AdapterManager');\n\n/**\n * Instances of this type manage visual widgets for resources shown in various\n * contexts. For example a person profile in a contact list has much less\n * details than the same user profile shown on a separate page. So resource\n * visualization depends on the <em>context</em> and on the <em>type</em> of\n * each resource. This class manages adapters for resource types in their\n * respective contexts.\n */\nvar ViewManager = Mosaic.Class.extend({\n\n    initialize : function(options) {\n        this.setOptions(options);\n        this._adapterManager = this.options.adapterManager || // \n        new AdapterManager();\n        if (this.options.getResourceType) {\n            this.getResourceType = this.options.getResourceType;\n        }\n    },\n\n    /**\n     * Registers visualization widget for all resources of the specified type\n     * shown in the contexts with the given viewType.\n     */\n    registerView : function(viewType, resourceType, View) {\n        this._adapterManager.registerAdapter(viewType, resourceType, View);\n    },\n\n    /** Creates and returns a new view for the specified resource type. */\n    newView : function(viewType, resourceType, options) {\n        return this._adapterManager.newAdapterInstance(viewType, resourceType,\n                options);\n    },\n\n    /**\n     * Returns the type of the specified object. This method should be\n     * overloaded in subclasses or in the constructor parameters.\n     */\n    getResourceType : function(d) {\n        return d.type || '';\n    },\n\n});\n\nmodule.exports = ViewManager;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ViewManager.js\n ** module id = 25\n ** module chunks = 0\n **/","/* ================================================================== */\n/* URI */\n/* ================================================================== */\n\nURI.toURI = function(obj) {\n    return new URI(obj).toString();\n};\nURI.parse = function(str) {\n    return new URI(str);\n};\n\n/** Constructor */\nfunction URI(url) {\n    this.reset();\n    if (typeof (url) === 'string') {\n        this.setURI(url);\n    } else if (typeof (url) === 'object') {\n        URI._doCopy(url, this, true);\n    }\n}\n\n/* ----------------------------------------------------------------- */\n/* URI static utility methods */\n/* ----------------------------------------------------------------- */\n\nfunction isArray(obj) {\n    if (!obj)\n        return false;\n    if (Array.isArray) {\n        return Array.isArray(obj);\n    } else {\n        return Object.prototype.toString.call(obj) == '[object Array]';\n    }\n}\n\n/** Splits the given query string to an object */\nURI.splitQuery = function(query) {\n    var result = {};\n    if (query && query !== '') {\n        var array = query.split('&');\n        for (var i = 0; i < array.length; i++) {\n            var str = array[i];\n            var parts = str.split('=');\n            var key = decodeURIComponent(parts[0]);\n            var value = decodeURIComponent(parts[1]);\n            if (!(key in result)) {\n                result[key] = value;\n            } else {\n                var prev = result[key];\n                var values = prev;\n                if (!isArray(values)) {\n                    values = result[key] = [ prev ];\n                }\n                values.push(value);\n            }\n        }\n    }\n    return result;\n};\n\n/** Serializes the specified query object as a string */\nURI.serializeQuery = function(query) {\n    var result = '';\n    for ( var key in query) {\n        if (query.hasOwnProperty(key)) {\n            var value = query[key] || '';\n            var k = encodeURIComponent(key);\n            var array = value;\n            if (!isArray(array)) {\n                array = [ value ];\n            }\n            for (var i = 0; i < array.length; i++) {\n                if (result.length > 0) {\n                    result += '&';\n                }\n                var v = encodeURIComponent(array[i]);\n                result += k;\n                result += '=';\n                result += v;\n            }\n        }\n    }\n    return result;\n};\n\nfunction isEmptySegment(segment) {\n    return segment === '' || segment === '.' || segment === '..';\n}\n\n/** This method resolves all path segments in the specified array. */\nURI.resolvePathSegments = function(segments, skipTraling) {\n    // Resolve the merged path\n    var result = false;\n    var len = segments.length;\n    var before = isEmptySegment(segments[0]);\n    var after = isEmptySegment(segments[len - 1]);\n    for (var i = 0; i < len; i++) {\n        var segment = segments[i];\n        if (isEmptySegment(segment)) {\n            result = false;\n            segments.splice(i, 1);\n            len--;\n            i--;\n            if ('..' == segment && i >= 0) {\n                segments.splice(i, 1);\n                len--;\n                i--;\n            }\n        } else {\n            result = true;\n        }\n    }\n    if (before) {\n        segments.splice(0, 0, '');\n    }\n    if (after) {\n        segments = segments.push('');\n    }\n    return result;\n};\n\nURI._doCopy = function(from, to, deep) {\n    for ( var key in from) {\n        if (!from.hasOwnProperty(key))\n            continue;\n        var value = from[key];\n        if ((typeof (value) === 'object') && deep) {\n            value = URI._doCopy(value, {});\n        }\n        to[key] = value;\n    }\n    return to;\n};\n\n/* ----------------------------------------------------------------- */\n/* Main URI methods definition */\n/* ----------------------------------------------------------------- */\n\n/** Cleans up all internal fields */\nURI.prototype.reset = function(keepPath, keepDomain) {\n    if (!keepDomain) {\n        delete this.scheme;\n        delete this.authority;\n        delete this.domain;\n        delete this.port;\n    }\n    if (!keepPath) {\n        delete this.path;\n        delete this.query;\n        delete this.fragment;\n    }\n};\n\n/** Cleans up all fields but 'path', 'query' and 'fragment' */\nURI.prototype.resetDomain = function() {\n    this.reset(true);\n};\n\n/** Returns serialized JSON representation of this URI */\nURI.prototype.asJSON = function(spaces) {\n    return JSON.stringify(this, null, spaces);\n};\n\n/** Creates and returns a new copy of this object */\nURI.prototype.newCopy = function() {\n    var copy = this.newInstance();\n    URI._doCopy(this, copy, true);\n    return copy;\n};\n\n/** Creates and returns a new instance of this type */\nURI.prototype.newInstance = function() {\n    return new URI();\n};\n\n/**\n * This method splits the given URI to individual URI parts\n * <ul>\n * <li>scheme</li>\n * <li>authority part (user info + domain name)</li>\n * <li>domain - in lower case</li>\n * <li>port - a number; 0 - if the port is not defined</li>\n * <li>path - starts with '/' or null if is not defined</li>\n * <li>query</li>\n * <li>fragment</li>\n * </ul>\n */\nURI.prototype.setURI = function(url) {\n    url = url || '';\n    url = url.replace(/[\\\\]/gi, '/');\n    var idx = url.lastIndexOf('#');\n    if (idx >= 0) {\n        this.fragment = url.substring(idx + 1);\n        url = url.substring(0, idx);\n    }\n    idx = url.indexOf('?');\n    if (idx >= 0) {\n        var str = url.substring(idx + 1);\n        this.query = URI.splitQuery(str);\n        url = url.substring(0, idx);\n    }\n\n    var hasDomain = false;\n    if (url.match(/^\\/\\//)) {\n        url = url.substring('//'.length);\n        hasDomain = true;\n    } else {\n        idx = url.indexOf('://');\n        if (idx >= 0) {\n            this.scheme = url.substring(0, idx);\n            url = url.substring(idx + '://'.length);\n            hasDomain = true;\n        }\n    }\n    if (hasDomain) {\n        idx = url.indexOf('/');\n        if (idx >= 0) {\n            this.path = url.substring(idx);\n            url = url.substring(0, idx);\n        }\n        idx = url.indexOf(':');\n        if (idx >= 0) {\n            try {\n                this.port = parseInt(url.substring(idx + 1));\n            } catch (e) {\n            }\n            url = url.substring(0, idx);\n        }\n        idx = url.indexOf('@');\n        if (idx >= 0) {\n            this.authority = url.substring(0, idx);\n            url = url.substring(0, idx);\n        }\n        this.domain = url.toLowerCase();\n    } else {\n        this.path = url;\n    }\n    return this;\n};\n\nfunction hasTrailingSeparator(str) {\n    if (!str || str === '')\n        return false;\n    if (str[str.length - 1] === '/')\n        return true;\n    return false;\n}\n\n/**\n * This method resolves the specified URI object relative to this URI and\n * returns a new resolved URI instance.\n */\nURI.prototype.resolve = function(urlObj) {\n    if (typeof urlObj === 'string') {\n        urlObj = new URI(urlObj);\n    }\n    // Don't try to resolve absolute URIs\n    if (urlObj.domain && '' !== urlObj.domain)\n        return urlObj.newCopy();\n    var base = this.newCopy();\n    var urlPath = urlObj.path;\n    if (urlPath.indexOf('/') !== 0) {\n        var basePath = base.path;\n        var idx = basePath.lastIndexOf('/');\n        // Create a global array of segments containing base\n        // segments\n        // and\n        // URL path segments.\n        var segments = basePath.split(/[\\/]/gi);\n        var baseTrailingSeparator = hasTrailingSeparator(basePath);\n        if (!baseTrailingSeparator) {\n            // Remove the last segment ('file name') of the base\n            // URL.\n            segments.pop();\n        }\n        var urlSegments = urlPath.split(/[\\/]/gi);\n        for (var i = 0; i < urlSegments.length; i++) {\n            var segment = urlSegments[i];\n            segments.push(segment);\n        }\n        var before = segments[0] === '';\n        var after = segments.length > 0 && //\n        segments[segments.length - 1] === '';\n        URI.resolvePathSegments(segments, true);\n        base.path = segments.join('/');\n        // if (before) {\n        // base.path = '/' + base.path;\n        // }\n        // if (after) {\n        // base.path += '/';\n        // }\n    } else {\n        base.path = urlPath;\n    }\n    base.query = urlObj.query;\n    base.fragment = urlObj.fragment;\n    return base;\n};\n\n/**\n * This method serializes the object containing individual parts of URIs.\n */\nURI.prototype.toString = function() {\n    var result = '';\n    if (this.scheme) {\n        result = this.scheme;\n    }\n    if (this.authority || this.domain) {\n        if (result !== '') {\n            result += ':';\n        }\n        result += '//';\n    }\n    if (this.authority) {\n        result += this.authority;\n        result += '@';\n    }\n    if (this.domain) {\n        result += this.domain;\n    }\n    if (this.port) {\n        result += ':' + this.port;\n    }\n    if (this.path !== '') {\n        if (result.length > 0 && !this.path.match(/^[\\/]/)) {\n            result += '/';\n        }\n        result += this.path;\n    }\n    if (this.query) {\n        var q = this.query;\n        if ((typeof q) != 'string') {\n            q = URI.serializeQuery(q);\n        }\n        result += '?' + q;\n    }\n    if (this.fragment) {\n        result += '#' + this.fragment;\n    }\n    return result;\n};\n\nmodule.exports = URI;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/URI.js\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_27__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"underscore\"\n ** module id = 27\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mosaic-teleport\"\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react\"\n ** module id = 29\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_30__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"leaflet\"\n ** module id = 30\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar L = require('leaflet');\nvar MapTiles = require('./Leaflet.MapTiles');\n\n/**\n * The code of this class was mostly copied from the leaflet.utfgrid Leaflet\n * extension (MIT license, by David Leaver). The difference with the original\n * implementation is that 1) this class loads tiles using _loadTiles method; 2)\n * this class notifies about loading of tiles for each new screen using the\n * \"startLoading\"/\"endLoading\" events; 3) it loads tiles starting from the\n * center of the current screen.\n */\nvar InteractionLayer = L.Class.extend({\n\n    includes : L.Mixin.Events,\n\n    options : {\n        resolution : 4,\n        pointerCursor : true\n    },\n\n    /** Initializes this layer */\n    initialize : function(options) {\n        L.setOptions(this, options);\n        // this._move = _.throttle(this._move, 20);\n        // this._update = _.debounce(this._update, 10);\n    },\n\n    /**\n     * This method is called when this layer is added to the map.\n     */\n    onAdd : function(map) {\n        this._map = map;\n        this._container = this._map._container;\n        // this._update();\n        // map.on('click', this._click, this);\n        map.on('mousemove', this._move, this);\n        // map.on('moveend', this._update, this);\n    },\n\n    /**\n     * This method is called when this layer is removed from the map.\n     */\n    onRemove : function() {\n        var map = this._map;\n        map.off('click', this._click, this);\n        map.off('mousemove', this._move, this);\n        // map.off('moveend', this._update, this);\n        this._removeMouseCursorStyle();\n    },\n\n    /** Map click handler */\n    _click : function(e) {\n        var on = this._objectForEvent(e);\n        if (on.data) {\n            this.fire('click', on);\n        }\n    },\n\n    /** Map move handler */\n    _move : function(e) {\n        var on = this._objectForEvent(e);\n        if (on.data !== this._mouseOn) {\n            if (this._mouseOn) {\n                this.fire('mouseout', {\n                    latlng : e.latlng,\n                    data : this._mouseOn\n                });\n                this._removeMouseCursorStyle();\n            }\n            if (on.data) {\n                this.fire('mouseover', on);\n                this._setMouseCursorStyle();\n            }\n            this._mouseOn = on.data;\n        } else if (on.data) {\n            this.fire('mousemove', on);\n        }\n    },\n\n    /**\n     * Checks if the cursor style of the container should be changed to pointer\n     * cursor\n     */\n    _setMouseCursorStyle : function() {\n        if (!this.options.pointerCursor)\n            return;\n        if (!this._container._pointerCursorCount) {\n            this._container._pointerCursorCount = 1;\n            this._container.style.cursor = 'pointer';\n        } else {\n            this._container._pointerCursorCount++;\n        }\n    },\n\n    /** Removes cursor style from the container */\n    _removeMouseCursorStyle : function() {\n        if (!this.options.pointerCursor)\n            return;\n        if (this._container._pointerCursorCount) {\n            this._container._pointerCursorCount--;\n            if (this._container._pointerCursorCount === 0) {\n                this._container.style.cursor = '';\n                delete this._container._pointerCursorCount;\n            }\n        }\n    },\n\n    /**\n     * Returns an object from UTF grid corresponding to the coordinates of the\n     * mouse event.\n     */\n    _objectForEvent : function(e) {\n        throw new Error('This method should be implemented ' + //\n        'in subclasses.');\n    },\n\n});\n\nmodule.exports = InteractionLayer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Leaflet.InteractionLayer.js\n ** module id = 31\n ** module chunks = 0\n **/","var _ = require('underscore');\nvar L = require('leaflet');\nvar Mosaic = require('mosaic-commons');\n\n/**\n * Common superclass for all map layers loading tiles using an external loader\n * object.\n */\nmodule.exports = L.Class.extend({\n\n    includes : L.Mixin.Events,\n\n    /** Initializes this layer */\n    initialize : function(options) {\n        L.setOptions(this, options);\n        _.defaults(this.options, {\n            minZoom : 0,\n            maxZoom : 25,\n            tileSize : 256\n        });\n    },\n\n    /**\n     * This method is called when this layer is added to the map.\n     */\n    onAdd : function(map) {\n        this._map = map;\n        this._container = this._map._container;\n        this._update();\n    },\n\n    /**\n     * This method is called when this layer is removed from the map.\n     */\n    onRemove : function() {\n    },\n\n    /** Re-loads tiles for new map position */\n    _update : function() {\n        // Check if tiles should be loaded\n        var zoom = this._map.getZoom();\n        var tileSize = this.options.tileSize;\n        if (zoom > this.options.maxZoom || //\n        zoom < this.options.minZoom) {\n            return;\n        }\n\n        // Load tiles\n        var bounds = this._map.getPixelBounds();\n        var min = this._getTilePosition(bounds.min);\n        var max = this._getTilePosition(bounds.max);\n        var queue = this._getTilesReferencesFromCenterOut(min, max);\n\n        var evt = {\n            queue : queue\n        };\n        var that = this;\n        that.fire('startLoading', evt);\n        that.options.loadTiles(zoom, queue, function(err, tiles) {\n            if (err) {\n                evt.errors = err;\n            }\n            evt.tiles = tiles;\n            that.fire('endLoading', evt);\n        });\n\n        /**\n         * Loads tiles corresponding to points specified in the 'queue'\n         * parameter of this method and returns these tiles using the given\n         * callback method. The first parameter of this method is an error and\n         * the second one is the resulting tiles.\n         */\n        this.options.loadTiles = function(zoom, queue, callback) {\n            callback(new Error('Not implemented'));\n        };\n    },\n\n    /** Calculates order of tiles loading */\n    _getTilesReferencesFromCenterOut : function(min, max) {\n        var queue = [];\n        for (var j = min.y; j <= max.y; j++) {\n            for (var i = min.x; i <= max.x; i++) {\n                queue.push(this._newPoint(i, j));\n            }\n        }\n        if (queue.length) {\n            var that = this;\n            var center = this._newPoint((min.x + max.x) / 2,\n                    (min.y + max.y) / 2);\n            queue.sort(function(a, b) {\n                var delta = that._distance(a, center) - //\n                that._distance(b, center);\n                return delta;\n            });\n        }\n        return queue;\n    },\n\n    /**\n     * Creates and returns a new point object (containing X/Y coordinates).\n     */\n    _newPoint : function(x, y) {\n        if (x.length) {\n            y = x[1];\n            x = x[0];\n        }\n        return {\n            x : x,\n            y : y,\n            toString : function() {\n                return JSON.stringify(this, null, 2);\n            }\n        };\n    },\n\n    /**\n     * Calculates distance between two points. This method is used to calculate\n     * order of tiles loading.\n     */\n    _distance : function(a, b) {\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        return Math.sqrt(x * x + y * y);\n    },\n\n    /**\n     * Returns X/Y coordinates of the tile corresponding to the specified point\n     * on the map\n     */\n    _getTilePosition : function(point) {\n        var tileSize = this.options.tileSize;\n        return this._newPoint(Math.floor(point.x / tileSize), Math\n                .floor(point.y / tileSize));\n    },\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Leaflet.MapTiles.js\n ** module id = 32\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"mosaic-core.js"}